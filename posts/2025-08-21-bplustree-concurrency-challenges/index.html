<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Practical Hurdles In Crab Latching Concurrency</title>
    <meta name="description" content="On database building blocks.">
    <meta name="generator" content="Eleventy v1.0.1">
    <link rel="stylesheet" href="/css/prism-okaidia.css">
    <link rel="stylesheet" href="/css/custom.css?v=1758984156359">
    <link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="">
    <link rel="alternate" href="/feed/feed.json" type="application/json" title="">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inria+Serif:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
    <script>document.documentElement.classList.remove("no-js");</script>
  </head>
  <body>
    <div class="page-wrapper">
      <header>
        <hgroup>
        <p><a href="/">Jacob&#39;s blog</a></p>
        <p>On database building blocks.</p>
      </hgroup>
        <ul class="nav">
          <li class="nav-item"><a href="/">posts</a></li>
          <li class="nav-item"><a href="/about/">whoami</a></li>
        </ul>
      </header>

      <main class="tmpl-post">
        

<div class="post-title-group">
  <h1>Practical Hurdles In Crab Latching Concurrency</h1>
  <time datetime="2025-08-21">21-Aug-2025</time>
</div>

<p>An implementation of the crab latching protocol enforces a strict top-down order for acquiring latches on a B+Tree node. This avoid deadlocks from ever occurring during concurrent operations. This is distinct from deadlock detection and resolution which is a runtime mechanism.</p>
<p>Deadlock avoidance is guaranteed by design through careful programming of critical sections in the code. Any mistakes here will result in deadlocks. Even worse, a data race which silently corrupts the index.</p>
<p>The main strength of a B+Tree index (compared to a hash index) is its unique capability to perform range scans. This is possible because all the entries are stored in key lexicographic order in the leaf nodes, and the leaf nodes themselves are connected to each other like a doubly-linked list. So scanning is efficient once you locate the starting leaf node. Scanning in ascending or descending key order is as simple as following the left or right sibling pointers.</p>
<p>This forwards or backwards movement during index scans violates the strict top-down ordering required for safety and correctness by the crab latching protocol.</p>
<p>A delete algorithm which implements a symmetrical tree rebalancing procedure requires acquiring an exclusive latch on either a left or right sibling for merging nodes. There is an equal chance of nodes merging left-right and right-left. This too violates the strict ordering requirement.</p>
<p>Therefore, an implementation has to come up with practical methods to avoid serial execution order and preserve concurrency. There is no formal verification of correctness via proof in these scenarios. We can improve our confidence in the implementation through engineering effort: code reviews, test suites, analyzers (ThreadSanitizer). Though the existence of data races cannot be ruled out, in practice this is sufficient for a robust and reliable implementation as evidenced by major OLTP systems.</p>
<nav class="toc" aria-labelledby="toc-heading">
  <h2 id="toc-heading">Table of Contents</h2>
  <ol>
    <li>
      <a href="#an-overview-of-crab-latching">An Overview Of Crab Latching</a>
      <ul>
        <li><a href="#the-classic-deadlock-scenario">The Classic Deadlock Scenario</a></li>
        <li><a href="#crab-latching-is-efficient">Crab Latching is Efficient</a></li>
        <li><a href="#optimistic-concurrency">Optimistic Concurrency</a></li>
      </ul>
    </li>
    <li>
      <a href="#concurrent-index-scans">Concurrent Index Scans</a>
      <ul>
        <li><a href="#extension-for-concurrent-bi-directional-scans">Extension For Concurrent Bi-directional Scans</a></li>
        <li><a href="#deadlock:-lock-order-inversion">Deadlock: Lock Order Inversion</a></li>
      </ul>
    </li>
    <li><a href="#extension-for-symmetric-deletion">Extension For Symmetric Deletion</a></li>
    <li><a href="#concurrent-scans-can-miss-entries">Concurrent Scans Can Miss Entries</a></li>
  </ol>
</nav>
<h2 id="an-overview-of-crab-latching" tabindex="-1">An Overview Of Crab Latching <a class="direct-link" href="#an-overview-of-crab-latching" aria-hidden="true"></a></h2>
<p>A thread can acquire either a shared read-only latch (s-latch) or an exclusive write latch (x-latch). A thread holding an x-latch blocks other threads until it completes its mutation of the node. Multiple reader threads holding an s-latch can concurrently access a node but are prevented from mutating the node itself. This is a basic single writer, multiple readers concurrency pattern.</p>
<p>In the crab latching protocol, during traversal a thread holding a latch on a B+Tree node attempts to acquire a latch on the next node. It must release the latch on the previous node only after it has acquired the latch on the next node. The name likely comes from how this mimics the latching movement of a crab.</p>
<h3 id="the-classic-deadlock-scenario" tabindex="-1">The Classic Deadlock Scenario <a class="direct-link" href="#the-classic-deadlock-scenario" aria-hidden="true"></a></h3>
<p>A deadlock occurs when two threads attempt to crab latch going in opposing directions. Consider a simple scenario with a parent Node-P and a child Node-C:</p>
<ol>
<li>Thread-1 traverses <em>top-down</em> from Node-P to Node-C to insert a new element.</li>
<li>Thread-2 moves <em>bottom-up</em>, from Node-C to update a pivot key in its parent Node-P.</li>
</ol>
<p>Remember that in crab latching protocol, a thread has to first acquire the latch on the next node before it can release the existing latch it holds on the current node. Also, an x-latch allows access to only a single writer thread. Therefore both write operations will block each other indefinitely as they cross paths, creating a deadlock as shown below.</p>
<figure>
              <img src="img/btree-deadlock-wait.svg" alt="circular wait deadlock">
              <figcaption>Figure 1. Thread-1 has acquired an exclusive write latch (x-latch) on Node-P and it is blocked waiting to acquire an x-latch on Node-C. Thread-2 already holds an x-latch on Node-C and it is blocked waiting to acquire an x-latch on Node P.</figcaption>
            </figure>
<p>A simple rule prevents this situation: acquire latches moving in only one direction. Since all B+Tree operations begin with a top-down traversals, enforcing a top-down order is the natural way to prevent deadlocks from occurring by design.</p>
<h3 id="crab-latching-is-efficient" tabindex="-1">Crab Latching is Efficient <a class="direct-link" href="#crab-latching-is-efficient" aria-hidden="true"></a></h3>
<blockquote>
<p>Latches are held only during a critical section, that is, while a data structure is read or updated. Deadlocks are avoided by appropriate coding disciplines, for example, requesting multiple latches in carefully designed sequences. Deadlock resolution requires a facility to rollback prior actions, whereas deadlock avoidance does not. Thus, deadlock avoidance is more appropriate for latches, which are designed for minimal overhead
and maximal performance and scalability. Latch acquisition and release may
require tens of instructions only, usually with no additional cache faults since a latch can be embedded in the data structure it protects.</p>
<p>Goetz Graefe, <a href="https://15721.courses.cs.cmu.edu/spring2016/papers/a16-graefe.pdf">A Survey of B-Tree Locking Techniques (2010)</a></p>
</blockquote>
<p>As Graefe notes, latches are designed for performance. By embedding a latch within each B+Tree node and holding it only for the brief duration of the operation, the protocol achieves fine-grained latching. This approach minimizes contention between threads and maximizes throughput for concurrent operations.</p>
<h3 id="optimistic-concurrency" tabindex="-1">Optimistic Concurrency <a class="direct-link" href="#optimistic-concurrency" aria-hidden="true"></a></h3>
<p>Crab latching is a pessimistic concurrency protocol. During a write, a node may split or merge, cascading changes up to the root. In this approach, a thread acquires an x-latch along the entire path from root to leaf. A single writer holding the root's x-latch blocks all other threads, effectively reducing concurrency to sequential execution.</p>
<p>The optimistic approach takes advantage of the fact that, in practice, node splits and merges are rare. In this &quot;fast path&quot;, the writer thread traverses the tree using s-latches, only upgrading to an x-latch on the final leaf node to perform the modification.</p>
<p>This requires minimal overhead to check if a child node is &quot;safe&quot; or &quot;unsafe&quot;. A node is unsafe if the write will cause a split or merge. If it encounters an unsafe node, the thread abandons the optimistic approach. It upgrades its latch on the parent to an x-latch and then acquires x-latches for the rest of the path segment. This &quot;slow path&quot; ensures rebalancing operations can proceed safely.</p>
<p>A notable benefit, even in the slow path, is that the x-latch path segment may be held on only a subsection of the tree, not extending all the way back to the root. This allows other operations to concurrently access different parts of the B+Tree.</p>
<h2 id="concurrent-index-scans" tabindex="-1">Concurrent Index Scans <a class="direct-link" href="#concurrent-index-scans" aria-hidden="true"></a></h2>
<p>The fundamental problem is that the concurrency models do not take into consideration B+Tree iterators. At the leaf node, traversing to a sibling uses the bi-directional links between leaf nodes. An ascending scan moves from left-right, while a descending scan moves from right-left. This conflicts with the safety property for avoiding deadlocks that traversals have a strictly enforced direction. Following the protocol exactly means the implementation can provide only one type of scan, either forward (ascending) or reverse (descending), but never both together.</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token comment">// A forward index scan</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> iter <span class="token operator">=</span> index<span class="token punctuation">.</span><span class="token function">Begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> index<span class="token punctuation">.</span><span class="token function">End</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>iter<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">int</span> key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span><br>  <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// A reverse index scan</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> iter <span class="token operator">=</span> index<span class="token punctuation">.</span><span class="token function">RBegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> index<span class="token punctuation">.</span><span class="token function">REnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">--</span>iter<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">int</span> key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span><br>  <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token comment">/**<br> * index.Begin()  : first element<br> * index.End()    : one-past-the-last element<br> * index.RBegin() : last element<br> * index.REnd()   : one-past-the-first element<br> */</span></code></pre>
<h3 id="extension-for-concurrent-bi-directional-scans" tabindex="-1">Extension For Concurrent Bi-directional Scans <a class="direct-link" href="#extension-for-concurrent-bi-directional-scans" aria-hidden="true"></a></h3>
<p>A shared (read-only) or exclusive (write) latch blocks execution until the latch is acquired. For scans which are sideways traversals, we do not want to limit the traversal to any one direction. A blocking latch will create deadlocks if two concurrent scans proceed in opposite directions.</p>
<p>Therefore we need to use a non-blocking latch to prevent blocking and avoid deadlocks. A non-blocking latch will try to acquire a latch, and will return immediately.</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;shared_mutex></span></span><br><br><span class="token keyword">class</span> <span class="token class-name">SharedLatch</span> <span class="token punctuation">{</span><br>  <span class="token comment">// Blocking</span><br>  <span class="token comment">//</span><br>  <span class="token comment">// If another thread holds the latch, execution will block</span><br>  <span class="token comment">// until the latch is acquired.</span><br>  <span class="token comment">//</span><br>  <span class="token comment">// Used in insert, delete &amp; search index operations</span><br>  <span class="token keyword">void</span> <span class="token function">LockShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      latch_<span class="token punctuation">.</span><span class="token function">lock_shared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token comment">// Non-blocking</span><br>  <span class="token comment">//</span><br>  <span class="token comment">// Tries to acquire a latch. If successful returns `true`,</span><br>  <span class="token comment">// otherwise returns `false`.</span><br>  <span class="token comment">//</span><br>  <span class="token comment">// Used in ascending &amp; descending index scans</span><br>  <span class="token keyword">bool</span> <span class="token function">TryLockShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> latch_<span class="token punctuation">.</span><span class="token function">try_lock_shared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">private</span><span class="token operator">:</span><br>    <span class="token comment">// A wrapper around std::shared_mutex</span><br>    std<span class="token double-colon punctuation">::</span>shared_mutex latch_<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>Using <code>TryLockShared()</code> forces us rethink how a scan implementation should work if latch acquisition fails. In contrast, the concurrent insert, delete and search implementations are always expected to return a result matching its output type in the signature.</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token comment">// Returns `std::nullopt` if the key is not found in the index</span><br>std<span class="token double-colon punctuation">::</span>optional<span class="token operator">&lt;</span>KeyType<span class="token operator">></span> <span class="token function">MaybeGet</span><span class="token punctuation">(</span>KeyType key<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Returns `false` if key is a duplicate.</span><br><span class="token comment">//</span><br><span class="token comment">// Note: This prevents overwriting an existing key. The handling of</span><br><span class="token comment">// duplicate keys is an implementation specific detail.</span><br><span class="token keyword">bool</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> KeyValuePair element<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Returns `false` if the key does not exist.</span><br><span class="token keyword">bool</span> <span class="token function">Delete</span><span class="token punctuation">(</span><span class="token keyword">const</span> KeyType key_to_remove<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>We can introduce a failure mode, where if latch acquisition fails during a scan we set its internal state to <code>RETRY</code>.</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">IteratorState</span> <span class="token punctuation">{</span><br>    VALID<span class="token punctuation">,</span> INVALID<span class="token punctuation">,</span> END<span class="token punctuation">,</span> REND<span class="token punctuation">,</span> RETRY<br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>The implementation for forward scan which uses a non-blocking latch and retriable iterator looks like this:</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token comment">// Move forward one element at a time. If latch acquisition</span><br><span class="token comment">// failed, then set internal state to `RETRY`.</span><br><span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// ...</span><br><br>  <span class="token comment">// The `TrySharedLock()` is a non-blocking read-only latch</span><br>  <span class="token comment">// which returns `true` or `false` immediately.</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>current_node_<span class="token operator">-></span><span class="token function">TrySharedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    previous_node<span class="token operator">-></span><span class="token function">ReleaseNodeSharedLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Invalidates the iterator.</span><br>    <span class="token comment">// Sets internal state to `RETRY`.</span><br>    <span class="token function">SetRetryIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">return</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token comment">// ...</span><br><br><span class="token punctuation">}</span><br><br><br><span class="token keyword">void</span> <span class="token function">SetRetryIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// Resets internal state</span><br>  current_node_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><br>  current_element_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><br><br>  state_ <span class="token operator">=</span> RETRY<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>We have a working bi-directional iterator implementation which will avoid deadlocks, but it is not yet free from data races.</p>
<h3 id="deadlock:-lock-order-inversion" tabindex="-1">Deadlock: Lock Order Inversion <a class="direct-link" href="#deadlock:-lock-order-inversion" aria-hidden="true"></a></h3>
<p>The current API introduces a deadlock if the user initializes two iterators within the same scope, within the same thread.</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> iter_forward <span class="token operator">=</span> index<span class="token punctuation">.</span><span class="token function">Begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// The second iterator creates a lock order inversion.</span><br><span class="token keyword">auto</span> iter_reverse <span class="token operator">=</span> index<span class="token punctuation">.</span><span class="token function">RBegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>A deadlock is prevented by enforcing a strict direction for latching. Any concurrent operation must therefore acquire a latch on an ancestor node before acquiring a latch on a descendant node (top-down traversal).</p>
<p>The iterator here holds a shared (read-only) latch on the leaf it points to. If that iterator remains alive while another operation begins a new top-down traversal from the root, we can get a deadlock.</p>
<p>(<code>Thread 1</code>): Creates a forward iterator, which holds a shared latch on a leaf node.</p>
<p>(<code>Thread 2</code>): Begins an insert in the pessimistic path acquiring an exclusive latch beginning at the root node all the way down to the parent of the same leaf node.</p>
<p>(<code>Thread 2</code>): Now attempts to acquire an exclusive latch on the leaf node but it blocks, waiting for the forward iterator to complete and release its shared latch on the leaf node.</p>
<p>(<code>Thread 1</code>): Creates a second reverse iterator, which is now blocking to acquire a shared lock on the root. It is waiting for the insert operation to release the exclusive latch.</p>
<p>This creates a deadlock, even though in implementation we enforced a strict ordering. We can ensure that this does not happen by ensuring that iterator lifetimes do not intersect each other, by introducing a local scope.</p>
<p>Most importantly, the shared latch is released at the end of the scope and therefore it also enforces a global ordering for latch acquisition and will not result in a deadlock like described above.</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token punctuation">{</span><br>  <span class="token keyword">auto</span> iter_forward <span class="token operator">=</span> index<span class="token punctuation">.</span><span class="token function">Begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// The lifetime of the first iterator ends before this</span><br><span class="token comment">// scope starts. This guarantees that the shared latch</span><br><span class="token comment">// on the leaf node is released before we start traversal</span><br><span class="token comment">// from the root node.</span><br><span class="token punctuation">{</span><br>  <span class="token keyword">auto</span> iter_reverse <span class="token operator">=</span> index<span class="token punctuation">.</span><span class="token function">RBegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>To ensure safety, the latching protocol has to be enforced for concurrent operations within the same thread. Unfortunately, our non-blocking, retriable concurrent scan iterators has introduced an API which is easy for the user to incorrectly implement, and must come with warnings.</p>
<p>The pattern of creating two iterators in the same scope creates a lock-order-inversion within a single thread. While this does not create a deadlock by itself, because of shared latches, it creates the precondition for a deadlock with any concurrent operation which falls down the pessimistic concurrency path.</p>
<h2 id="extension-for-symmetric-deletion" tabindex="-1">Extension For Symmetric Deletion <a class="direct-link" href="#extension-for-symmetric-deletion" aria-hidden="true"></a></h2>
<p>A symmetric delete algorithm will proceed with a tree rebalancing operation after an underflow by attempting to merge with either the left sibling, and if that doesn't work with the right sibling at any level in the B+Tree. This violates our strict ordering principle for acquiring latches, because a merge can proceed in either direction.</p>
<p>(<code>Thread 1</code>): operating on Node B, needs to merge with its previous sibling, Node A. It holds an exclusive latch on B and tries to acquire an exclusive latch on A. (left to right)</p>
<p>(<code>Thread 2</code>): operating on Node A, needs to merge with its next sibling, Node B. It holds an exclusive latch on A and tries to acquire an exclusive latch on B. (right to left)</p>
<p>The creates a deadlock.</p>
<p>The fix is to enforce a strict one-way (say left-to-right) latch acquisition order. This is a delicate operation. Before locking the previous sibling A, the exclusive lock on the current node is released. The locks are reacquired in the correct order. First on the previous sibling, then on the current node.</p>
<pre class="language-cpp"><code class="language-cpp"><br>  <span class="token keyword">auto</span> maybe_previous <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>InnerNode <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">MaybePreviousWithSeparator</span><span class="token punctuation">(</span>key_to_remove<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>maybe_previous<span class="token punctuation">.</span><span class="token function">has_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br><br>    <span class="token comment">/* ... */</span><br><br>    <span class="token comment">// Enforcing a strict left-to-right (one-way) ordering</span><br>    right<span class="token operator">-></span><span class="token function">ReleaseNodeExclusiveLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    left<span class="token operator">-></span><span class="token function">GetNodeExclusiveLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    right<span class="token operator">-></span><span class="token function">GetNodeExclusiveLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">/* ... */</span><br>  <span class="token punctuation">}</span></code></pre>
<h2 id="concurrent-scans-can-miss-entries" tabindex="-1">Concurrent Scans Can Miss Entries <a class="direct-link" href="#concurrent-scans-can-miss-entries" aria-hidden="true"></a></h2>
<p>Earlier in the case of concurrent scans we saw how local reasoning of strict ordering is not sufficient, because of the extension. A global strict ordering has to be enforced to prevent unintended deadlocks from interaction of scans with other concurrent operations.</p>
<p>Now let us look at a scenario where both the extensions can interact in a manner which violates strict ordering and introduces lock order inversion bugs in subtle ways.</p>
<p>(<code>Thread 1</code>): A forward scan iterator has completed scanning entries in Node A, and is next going to process it's right sibling Node B.</p>
<p>(<code>Thread 2</code>): A delete operation has taken the pessimistic path, because Node B is going to underflow after removing this entry. So it decides to merge with left sibling Node A. It already holds an exclusive latch on Node B and has to acquire an exclusive latch on Node B.</p>
<p>If the forward scan operator releases its shared latch on Node A, before it acquires a shared latch on Node B, the following sequence of events can happen with the right timing of events.</p>
<p>(<code>Thread 1</code>): Releases latch on Node A before acquiring a latch on Node B.</p>
<p>(<code>Thread 2</code>): Release exclusive latch on Node B. Acquires exclusive latch on Node A. Acquires the exclusive latch back on Node B.</p>
<p>(<code>Thread 1</code>): Is blocked by the exclusive latch held on Node B, by the delete operation in <code>Thread 2</code>.</p>
<p>(<code>Thread 2</code>): Merges Node A and B together, and modifies the right sibling pointer to Node C.</p>
<p>(<code>Thread 1</code>): Finally acquires a latch on Node C which is the new right sibling on Node A, not realizing it missed node B completely.</p>
<p>If latches acquisition is not crafted carefully in the iterator code, the following situation creates a race condition which is very hard to even detect, or reproduce.</p>
<p>The fix here is to correctly implement crab latching in the iterator code. A shared lock should not be released before <code>TrySharedLock()</code> is attempted on the sibling node. Doing so results in race conditions which are impossible to track down. This requires careful programming discipline.</p>

<hr>
<ul><li>Next: <a href="/posts/2025-09-01-arrow-shredding-pipeline-perf/">Performance Tuning a Nested Data Generator for Parquet</a></li><li>Previous: <a href="/posts/2025-08-18-bplustree-struct-hack/">Cache-Friendly B+Tree Nodes With Dynamic Fanout</a></li>
</ul>

      </main>

      <footer></footer>

      <!-- Current page: /posts/2025-08-21-bplustree-concurrency-challenges/ -->
    </body>
  </div>
</html>
