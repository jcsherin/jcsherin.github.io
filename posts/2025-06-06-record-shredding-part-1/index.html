<style>
th, td {
  text-align: center;
  vertical-align: top;
  padding: 8px 16px;
}

.table-container {
  display: flex;
  justify-content: space-around;
  gap: 20px;
}

.col-view td:nth-child(1), .col-view th:nth-child(1):not([colspan]) { background-color: #FFFFE0; }
.col-view td:nth-child(2), .col-view th:nth-child(2) { background-color: #FFDAB9; }
.col-view td:nth-child(3), .col-view th:nth-child(3) { background-color: #E6E6FA; }
.col-view td:nth-child(4), .col-view th:nth-child(4) { background-color: #DDFADD; }
.col-view td:nth-child(5), .col-view th:nth-child(5) { background-color: #F0F8FF; }

.row-view tr:nth-child(1) td { background-color: #FFFFE0; }
.row-view tr:nth-child(2) td { background-color: #FFDAB9; }
.row-view tr:nth-child(3) td { background-color: #E6E6FA; }
.row-view tr:nth-child(4) td { background-color: #DDFADD; }

.col-view {
  border-spacing: 8px 0;
}

.row-view {
  border-spacing: 0 8px;
}

.record-container {
  display: flex;
}

.default-value {
  color: #555555;
}

/* to be removed later */
body {
  max-width: 800px;
  font-size: 20px;
  margin: 0 auto 220px;
}
</style>
<h1 id="introduction" tabindex="-1">Introduction <a class="direct-link" href="#introduction" aria-hidden="true">#</a></h1>
<p>In the 2010 VLDB
paper, <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36632.pdf">Dremel: Interactive Analysis of Web-Scale Datasets</a>
reports being able to run ad-hoc analytical queries over a <em>trillion-row</em> tables in seconds. The contents of the
table were nested data structures and not flat, relational data. The compressed size of the dataset exceeded 100TB
and the nested data structures contained around 50 fields.</p>
<p>The Dremel (underlying engine of Google BigQuery) folks invented a representation which for the first time made it
possible to represent nested data structures directly in the internal storage format of Dremel. This reduced the
average query execution time from hours to seconds. The provide the example of a query to compute the average number
of terms in a field. To compute the results the query had to scan 87TB of records stored in its original form,
compared to just 0.5TB of compressed data in the new representation. That is an impressive reduction in data scanned
from storage to compute query results.</p>
<p>This technique was directly adopted by Apache Parquet file format for efficiently storing and querying nested data
structures.</p>
<p>The design of the Dremel encoding is deceptively simple. In an attempt to implement my own version of this from
scratch - <a href="https://github.com/jcsherin/denester">https://github.com/jcsherin/denester</a>, I kept thinking I understand this enough to implement it and I can
also convince myself that it works correctly, but the intuition behind it was missing. Slogging through the
implementation after several tiny moments of epiphany, I finally understood its essence. This blog post is an
attempt to write it down not as a how to implement it, but really get to the bottom of why it works through first
principles reasoning and capture some of the magic and elegance in its design.</p>
<h1 id="record-shredding-and-assembly" tabindex="-1">Record Shredding And Assembly <a class="direct-link" href="#record-shredding-and-assembly" aria-hidden="true">#</a></h1>
<p>Conceptually, record shredding is a flattening of a nested data structure into a flat, relational format. Record
assembly is the reconstructing of that shredded structure back into its original nested form.</p>
<p>Below is a visualization of a <em>UserProfile</em> object which has three levels of nesting.</p>
<p><img src="img/bobthebuilder.svg" alt="Example nested data structure">
<em>Figure 1. Visualization of a nested data structure</em></p>
<p>The primitive values appear in the leaf nodes at levels two and three. It is common to use the dot-separated notation to
represent accessing a leaf node value (e.g. <em>preferences.theme</em> = <em>&quot;dark&quot;</em>). The array index notation is used to
represent accessing the individual values in the repeated (array) field like <em>tags</em> (e.g. tags[0] = <em>&quot;builder&quot;</em>, tags
[1] = <em>&quot;diy&quot;</em>).</p>
<p>After shredding the flattened <em>UserProfile</em> value looks like any other row in a relational table. The two array values
in <em>tags</em> are expanded into separate rows. This is similar to using the <em>UNNEST</em> function in SQL which takes the
array value in <em>tags</em> as input, and returns rows for each element in the array.</p>
<table class="col-view">
  <thead>
    <tr>
      <th colspan="5">Flattened UserProfile After Record Shredding</th>
    </tr>
    <tr>
      <th>uid</th>
      <th>displayName</th>
      <th>tags</th>
      <th>preferences.theme</th>
      <th>preferences.notifications</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>9012</td>
      <td>Bob The Builder</td>
      <td>builder</td>
      <td>dark</td>
      <td>false</td>
    </tr>
    <tr>
      <td>9012</td>
      <td>Bob The Builder</td>
      <td>diy</td>
      <td>dark</td>
      <td>false</td>
    </tr>
  </tbody>
</table>
<h2 id="record-assembly" tabindex="-1">Record Assembly <a class="direct-link" href="#record-assembly" aria-hidden="true">#</a></h2>
<p>Next record assembly takes these row values and the column names as input, to fully reconstruct the nested data
structure back to its original form.</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"uid"</span><span class="token operator">:</span> <span class="token string">"9012"</span><span class="token punctuation">,</span><br>  <span class="token property">"displayName"</span><span class="token operator">:</span> <span class="token string">"Bob The Builder"</span><span class="token punctuation">,</span><br>  <span class="token property">"tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token string">"builder"</span><span class="token punctuation">,</span><br>    <span class="token string">"diy"</span><br>  <span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token property">"preferences"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"theme"</span><span class="token operator">:</span> <span class="token string">"dark"</span><span class="token punctuation">,</span><br>    <span class="token property">"notifications"</span><span class="token operator">:</span> <span class="token boolean">false</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>Record assembly also works with just a subset of columns. This is a useful feature which closely matches real-world
usage. Most queries only include a small set of columns relevant to the query. There is no good reason to materialize
the a complete <em>UserProfile</em> if the query requires only parts of it.</p>
<p>If the columns specified in the query are <em>uid</em> and <em>preferences.notifications</em> then record assembly has to read
only these columns. It can skip the remaining columns which are not relevant to the query. The reassembled
<em>UserProfile</em> object preserves its original structure but only contains these fields:</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"uid"</span><span class="token operator">:</span> <span class="token string">"9012"</span><span class="token punctuation">,</span><br>  <span class="token property">"preferences"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"notifications"</span><span class="token operator">:</span> <span class="token boolean">false</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<h2 id="columnar-data-layout" tabindex="-1">Columnar Data Layout <a class="direct-link" href="#columnar-data-layout" aria-hidden="true">#</a></h2>
<p>It is implied above that record shredding and assembly uses a columnar data layout. And this is critical for
reassembly of partial projection from the shredded values in storage. It is an efficient representation because only
the subset of columns required for reassembly have to be scanned.</p>
<p>Typically relational data is associated with row storage. If you access the row (say <em>id</em> = 103) it retrieves all
the related attributes from storage and writes <em>(103, &quot;Eve&quot;, &quot;eavesdropper&quot;)</em> to memory. This matches the access
patterns of transactional applications which needs to read or write a single row or a very small set of rows at a
time. The row storage is optimized for heavy read-write workloads which works on a single row or a very small set of
rows.</p>
<table class="row-view">
  <thead>
    <tr>
      <th colspan="3">Row Format</th>
    </tr>
    <tr>
      <th>id</th>
      <th>username</th>
      <th>role</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>101</td>
      <td>Alice</td>
      <td>sender</td>
    </tr>
    <tr>
      <td>102</td>
      <td>Bob</td>
      <td>receiver</td>
    </tr>
    <tr>
      <td>103</td>
      <td>Eve</td>
      <td>eavesdropper</td>
    </tr>
    <tr>
      <td>104</td>
      <td>Trudy</td>
      <td>intruder</td>
    </tr>
  </tbody>
</table>
<p>The row storage format is not optimized for access patterns of analytical queries. For example to compute the value
of <em>COUNT (DISTINCT role)</em> all data will have to be retrieved from storage, written to memory and scanned to
compute the result. Even though the <em>id</em> and <em>username</em> columns serves no purpose in computing the final result,
they are still materialized into memory from storage. This is unavoidable because row value are stored next to each
other.</p>
<p>If the data is instead stored in a columnar layout, only the <em>role</em> column needs to be scanned to compute the final
result. In this layout the values of a column are stored next to each other.</p>
<table class="col-view">
  <thead>
    <tr>
      <th colspan="3">Columnar Format</th>
    </tr>
    <tr>
      <th>id</th>
      <th>username</th>
      <th>role</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>101</td>
      <td>Alice</td>
      <td>sender</td>
    </tr>
    <tr>
      <td>102</td>
      <td>Bob</td>
      <td>receiver</td>
    </tr>
    <tr>
      <td>103</td>
      <td>Eve</td>
      <td>eavesdropper</td>
    </tr>
    <tr>
      <td>104</td>
      <td>Trudy</td>
      <td>intruder</td>
    </tr>
  </tbody>
</table>
<p>In database terms this optimization is known as <em>projection pushdown</em>. It helps optimize the amount of disk I/O
necessary for scanning data from physical storage.</p>
<h1 id="schema" tabindex="-1">Schema <a class="direct-link" href="#schema" aria-hidden="true">#</a></h1>
<p>The schema is the single source of truth which is used for implementing record shredding and assembly.</p>
<p>A schema is a collection of <em>fields</em>. Each <em>field</em> has a name, a data type and a marker which identifies if the
field is optional or not.</p>
<p>A <em>repeated</em> field is an array of values. The data type can be either a primitive type or even a struct data type. The
order of values is important and is preserved during shredding and reassembly.</p>
<p>A <em>Struct</em> data type adds another level of nesting and contains one or more fields.</p>
<p><img src="img/schema_userprofile.svg" alt="UserProfile Schema">
<em>Figure 2. Schema of UserProfile object</em></p>
<p>The example below (same as Figure 1.) is a valid construction of the <em>UserProfile</em> schema. The <em>preferences.language</em>
property is not present in this instance. In the schema, the <em>language</em> field is marked as an optional field.</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"uid"</span><span class="token operator">:</span> <span class="token string">"9012"</span><span class="token punctuation">,</span><br>  <span class="token property">"displayName"</span><span class="token operator">:</span> <span class="token string">"Bob The Builder"</span><span class="token punctuation">,</span><br>  <span class="token property">"tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token string">"builder"</span><span class="token punctuation">,</span><br>    <span class="token string">"diy"</span><br>  <span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token property">"preferences"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"theme"</span><span class="token operator">:</span> <span class="token string">"dark"</span><span class="token punctuation">,</span><br>    <span class="token property">"notifications"</span><span class="token operator">:</span> <span class="token boolean">false</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>In the next example, the <em>preferences</em> property is not present. In the schema, the <em>preferences</em> field is marked as an
optional field.</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"uid"</span><span class="token operator">:</span> <span class="token string">"1234"</span><span class="token punctuation">,</span><br>  <span class="token property">"displayName"</span><span class="token operator">:</span> <span class="token string">"Alice Wonderland"</span><span class="token punctuation">,</span><br>  <span class="token property">"tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token string">"reader"</span><span class="token punctuation">,</span><br>    <span class="token string">"dreamer"</span><br>  <span class="token punctuation">]</span><br><span class="token punctuation">}</span></code></pre>
<p>In the next example, the <em>preferences.language</em> and <em>preferences.notifications</em> properties are not present. In the
schema both the fields are marked as optional.</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"uid"</span><span class="token operator">:</span> <span class="token string">"5678"</span><span class="token punctuation">,</span><br>  <span class="token property">"displayName"</span><span class="token operator">:</span> <span class="token string">"Chris Coder"</span><span class="token punctuation">,</span><br>  <span class="token property">"tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token string">"developer"</span><span class="token punctuation">,</span><br>    <span class="token string">"python"</span><span class="token punctuation">,</span><br>    <span class="token string">"oss"</span><br>  <span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token property">"preferences"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"theme"</span><span class="token operator">:</span> <span class="token string">"light"</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>The recurring theme here is that by looking at an instance of a nested structure by itself, it is not possible to
identify which properties are missing from it. We need the schema to validate an instance and also know which
properties are not present in it.</p>
<h1 id="the-dremel-encoding" tabindex="-1">The Dremel Encoding <a class="direct-link" href="#the-dremel-encoding" aria-hidden="true">#</a></h1>
<p>A desirable property of record shredding is that it should not inflate the size of the stored nested data structure.
If the shredded encoding ended up being smaller than directly storing the nested data structure itself, that will
be a great win.</p>
<p>The abstract representation of record shredding introduced in the beginning is not well-designed. The most obvious
issue is the data redundancy required for the <em>tags</em> repeated field. The number of rows in this representation
depends on the cardinality (number of elements) of the <em>tags</em> property.</p>
<p>Also to keep complexity low without sacrificing the essence of how record shredding works we deliberately did not tackle
the problem of how missing properties should be represented.</p>
<p>The three examples of <em>UserProfile</em> from above after shredding using the Dremel technique is represented as shown below.</p>
<table class="col-view">
  <thead>
    <tr>
      <th colspan="5">Dremel Encoding</th>
    </tr>
    <tr>
      <th>uid</th>
      <th>displayName</th>
      <th>tags</th>
      <th>preferences.theme</th>
      <th>preferences.notifications</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1234</td>
      <td>Alice Wonderland</td>
      <td>reader</td>
      <td>light</td>
      <td>false</td>
    </tr>
    <tr>
      <td>5678</td>
      <td>Chris Coder</td>
      <td>dreamer</td>
      <td>dark</td>
      <td></td>
    </tr>
    <tr>
      <td>9012</td>
      <td>Bob The Builder</td>
      <td>developer</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>python</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>oss</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>builder</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>diy</td>
      <td></td>
      <td></td>
    </tr>
  </tbody>
</table>
<p>This representation wastes no space for representing properties which are missing in the values. The cardinality of
a repeated field like <em>tags</em> has no effect on other columns. This representation ends up taking less space than
directly storing the <em>UserProfile</em> objects.</p>
<p>But they do not line up nicely into rows which informs you where a record begins and ends just by visual inspection.
So if you are thinking there is not enough information here to be able to reassemble the original values, you are on
the right track.</p>
<h2 id="structure-is-metadata" tabindex="-1">Structure is Metadata <a class="direct-link" href="#structure-is-metadata" aria-hidden="true">#</a></h2>
<p>A schema definition leads to a variety of possible structures. This can be seen in the below visualization of the three
<em>UserProfile</em> examples introduced earlier. Without the distraction of labels, we can look at the structure by itself.</p>
<p><img src="img/structure_userprofile.svg" alt="Tree node illustration of UserProfile objects">
<em>Figure 3. Structure of UserProfile Objects</em></p>
<p>What causes the structural variability?</p>
<p>If any of the optional fields are not present, or if a repeated (array) field is empty it manifests as a hole in the
structure. The cardinality of the repeated field also modifies the structure.</p>
<p>The key insight in Dremel encoding is to distill both these sources of structural variability into a computed
numeric value during the process of record shredding. By interpreting the values extracted from the leaf nodes
together with the two derived metadata values the original nested data structure can be reassembled.</p>
<p>In Dremel these metadata columns are known as <em>definition levels</em> and <em>repetition levels</em>.</p>
<h1 id="how-definition-levels-work" tabindex="-1">How Definition Levels Work <a class="direct-link" href="#how-definition-levels-work" aria-hidden="true">#</a></h1>
<p>Consider a single nested path of interleaving optional and repeated fields. The definition level is computed by
counting the optional fields which are present, and the repeated fields which are present and not empty.</p>
<p><img src="img/example_def_levels.svg" alt="Annotated definition levels for path with interleaving optional and repeated fields">
<em>Figure 4. Annotated definition levels for a nested path</em></p>
<p>The example path <em>a.b.c.d.e</em> shown above contains three optional fields and two repeated fields. The definition
levels for this path will be in the range (inclusive) [0, 5]. The calculation is simple. If a field is present then
we increment the definition level count. We continue doing this for each optional and repeated field until the path
terminates. The final count tell us exact point at which a path terminates.</p>
<p>In this example a definition level of zero indicates that the path is not present in the data instance. If a path
defined in the schema contains only required fields then the definition levels will be always zero for all values.
In this case we do not need to compute or store the definition levels. For example, the <em>uid</em> is a required field in
the <em>UserProfile</em> schema. We can simply skip computing definition levels as there are no optional or repeated fields
in this path.</p>
<table>
  <thead>
    <tr>
      <th>No.</th>
      <th>Path</th>
      <th>Definition Level</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Ã˜</td>
      <td>0</td>
      <td>Empty path. The field <em>a</em> is not present.</td>
    </tr>
    <tr>
      <td>2</td>
      <td>a</td>
      <td>1</td>
      <td>The repeated field <em>b</em> is empty and not present.</td>
    </tr>
    <tr>
      <td>3</td>
      <td>a.b</td>
      <td>2</td>
      <td>The optional field <em>c</em> is not present.</td>
    </tr>
    <tr>
      <td>4.</td>
      <td>a.b.c</td>
      <td>3</td>
      <td>The repeated field <em>d</em> is not present.</td>
    </tr>
    <tr>
      <td>5</td>
      <td>a.b.c.d</td>
      <td>4</td>
      <td>The optional field <em>e</em> is not present.</td>
    </tr>
    <tr>
      <td>6.</td>
      <td>a.b.c.d.e</td>
      <td>5</td>
      <td>All the fields in this path are present.</td>
    </tr>
  </tbody>
</table>
<h1 id="how-repetition-levels-work" tabindex="-1">How Repetition Levels Work <a class="direct-link" href="#how-repetition-levels-work" aria-hidden="true">#</a></h1>
<p>When compared to definition levels the computation of repetition levels is complicated.</p>
<p><img src="img/example_1_rep_levels.svg" alt="Repeated field with same value sequence but different arrangements">
<em>Figure 5. Nested repeated fields with similar values but different structures</em></p>
<p>All the examples in figure 5. have the same sequence of values. The repetition levels is the key metadata which has
to be computed during shredding which will allow us to reassemble any of them back to its original form.</p>
<p>The repetition level is a count of the repeated fields in a path. So the <em>n<sup>th</sup></em> repeated field will have a
repetition level of <em>n</em>. Non-repeated fields contribute to overall nesting of the structure but do not increment the
repetition level count.</p>
<p>Let us begin by computing the repetition levels for <em>Record 1</em>.</p>
<p>For simplicity let us substitute the outer list with variable names like <em>x</em> and <em>y</em> instead of the actual list
contents to reduce verbosity. So the outer list is <code>[x, y]</code> where <em>x</em> and <em>y</em> represents the original inner list
elements.</p>
<p>The first rule says, the repetition level of the first list element is the same as that of its parent repeated field.</p>
<p>The outer list is the first repeated field in this path and its repetition level is one. Since it does not have a
parent repeated field, we treat this as a special case and give <em>x</em> the repetition level of zero (instead of one) as
an application of the first rule.</p>
<p>The second rule is that every subsequent element within that same list will have a repetition level equal to the
repeated field.</p>
<p>The outer list has a repetition level of one. So the remaining elements which is just <em>y</em> will have a repetition
level of one.</p>
<p>What we have at this point is an intermediate result. The inner lists have not been evaluated.</p>
<table>
  <thead>
    <tr><th colspan="3">Intermediate Result</th></tr>
    <tr>
      <th>value</th>
      <th>contents</th>
      <th>repetition level</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>x</td>
      <td>[1, 2, 3]</td>
      <td>0</td>
    </tr>
    <tr>
      <td>y</td>
      <td>[4, 5, 6]</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>Let us next process <em>x</em> which is <em>[1, 2, 3]</em>.</p>
<p>The inner list is the second repeated field, so it has a repetition level of two. For the first element <em>1</em> we apply
<em>Rule 1</em>. The repetition level of <em>x</em> is zero, so the repetition level of <em>1</em> is also zero. For the remaining elements
<em>2</em> and <em>3</em>, the repetition level is two because this is the second repeated field.</p>
<table>
  <thead>
    <tr><th colspan="2">Intermediate Result</th></tr>
    <tr>
      <th>value</th>
      <th>repetition level</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>3</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
<p>Let us now process <em>y</em> which is <em>[4, 5, 6]</em>.</p>
<p>The repetition level is two for the inner list because it is the second repeated field. For the first element <em>4</em> we
again apply Rule 1. The repetition level of parent <em>y</em> is one, so the repetition level of <em>4</em> is also 1. For the
remaining elements <em>5</em> and <em>6</em> the repetition level is two because it is same as the repetition level of the inner list.</p>
<table>
  <thead>
    <tr><th colspan="2">Intermediate Result</th></tr>
    <tr>
      <th>value</th>
      <th>repetition level</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>4</td>
      <td>1</td>
    </tr>
    <tr>
      <td>5</td>
      <td>2</td>
    </tr>
    <tr>
      <td>6</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
<p>All the repeated fields have been counted and all list elements accounted for. Now all we have to do is merge the
intermediate results.</p>
<table>
  <thead>
    <tr><th colspan="2">Final Result</th></tr>
    <tr>
      <th>value</th>
      <th>repetition level</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>3</td>
      <td>2</td>
    </tr>
    <tr>
      <td>4</td>
      <td>1</td>
    </tr>
    <tr>
      <td>5</td>
      <td>2</td>
    </tr>
    <tr>
      <td>6</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
<p>By recursively applying the process to all repeated fields the repetition levels can be computed for other records
as well. This is the final computed repetition levels without the intermediate work shown. You are free to verify
its correctness by trying to apply the rules and trying to compute the values by yourself.</p>
<table>
  <thead>
    <tr>
      <th></th>
      <th colspan="3">Repetition Levels</th>
    </tr>
    <tr>
      <th>values</th>
      <th>Record 1</th>
      <th>Record 2</th>
      <th>Record 3</th>
      <th>definition levels</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>2</td>
    </tr>
    <tr>
      <td>2</td>
      <td>2</td>
      <td>2</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>3</td>
      <td>2</td>
      <td>1</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <td>4</td>
      <td>1</td>
      <td>2</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>5</td>
      <td>2</td>
      <td>1</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>6</td>
      <td>2</td>
      <td>2</td>
      <td>2</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
<h1 id="conclusion" tabindex="-1">Conclusion <a class="direct-link" href="#conclusion" aria-hidden="true">#</a></h1>
