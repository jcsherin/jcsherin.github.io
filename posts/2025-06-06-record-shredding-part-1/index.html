<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Record Shredding: Part 1</title>
    <meta name="description" content="jcsherin writes about programming">
    <meta name="generator" content="Eleventy v1.0.1">

    <link rel="stylesheet" href="/css/index.css">
    <link rel="stylesheet" href="/css/prism-base16-monokai.dark.css">
    <link rel="stylesheet" href="/css/prism-diff.css">
    <link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="jcsherin">
    <link rel="alternate" href="/feed/feed.json" type="application/json" title="jcsherin">
  </head>
  <body>
    <header>
      <h1 class="home"><a href="/">jcsherin</a></h1>
      <ul class="nav">
        <li class="nav-item"><a href="/">Home</a></li>
        <li class="nav-item"><a href="/posts/">Archive</a></li>
        <li class="nav-item"><a href="/about/">About Me</a></li>
      </ul>
    </header>

    <main class="tmpl-post">
      <h1>Record Shredding: Part 1</h1>

<time datetime="2025-06-06">06 Jun 2025</time>

<style>
th, td {
  text-align: center;
  vertical-align: top;
  padding: 8px 16px;
}

.table-container {
  display: flex;
  justify-content: space-around;
  gap: 20px;
}

.col-view td:nth-child(1), .col-view th:nth-child(1):not([colspan]) { background-color: #FFFFE0; }
.col-view td:nth-child(2), .col-view th:nth-child(2) { background-color: #FFDAB9; }
.col-view td:nth-child(3), .col-view th:nth-child(3) { background-color: #E6E6FA; }
.col-view td:nth-child(4), .col-view th:nth-child(4) { background-color: #DDFADD; }
.col-view td:nth-child(5), .col-view th:nth-child(5) { background-color: #F0F8FF; }

.row-view tr:nth-child(1) td { background-color: #FFFFE0; }
.row-view tr:nth-child(2) td { background-color: #FFDAB9; }
.row-view tr:nth-child(3) td { background-color: #E6E6FA; }
.row-view tr:nth-child(4) td { background-color: #DDFADD; }

.col-view {
  border-spacing: 8px 0;
}

.row-view {
  border-spacing: 0 8px;
}

.record-container {
  display: flex;
}

.default-value {
  color: #555555;
}

/* to be removed later */
body {
  max-width: 800px;
  font-size: 20px;
  margin: 0 auto 220px;
}
</style>
<h1 id="introduction" tabindex="-1">Introduction <a class="direct-link" href="#introduction" aria-hidden="true">#</a></h1>
<p>In the 2010 VLDB
paper, <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36632.pdf">Dremel: Interactive Analysis of Web-Scale Datasets</a>
reports being able to run ad-hoc analytical queries over a <em>trillion-row</em> tables in seconds. The contents of the
table were nested data structures and not flat, relational data. The compressed size of the dataset exceeded 100TB
and the nested data structures contained around 50 fields.</p>
<p>The Dremel (underlying engine of Google BigQuery) folks invented a representation which for the first time made it
possible to represent nested data structures directly in the internal storage format of Dremel. This reduced the
average query execution time from hours to seconds. The provide the example of a query to compute the average number
of terms in a field. To compute the results the query had to scan 87TB of records stored in its original form,
compared to just 0.5TB of compressed data in the new representation. That is an impressive reduction in data scanned
from storage to compute query results.</p>
<p>This technique was directly adopted by Apache Parquet file format for efficiently storing and querying nested data
structures.</p>
<p>The design of the Dremel encoding is deceptively simple. In an attempt to implement my own version of this from
scratch - <a href="https://github.com/jcsherin/denester">https://github.com/jcsherin/denester</a>, I kept thinking I understand this enough to implement it and I can
also convince myself that it works correctly, but the intuition behind it was missing. Slogging through the
implementation after several tiny moments of epiphany, I finally understood its essence. This blog post is an
attempt to write it down not as a how to implement it, but really get to the bottom of why it works through first
principles reasoning and capture some of the magic and elegance in its design.</p>
<h1 id="record-shredding-and-assembly" tabindex="-1">Record Shredding And Assembly <a class="direct-link" href="#record-shredding-and-assembly" aria-hidden="true">#</a></h1>
<p>Conceptually, record shredding is a flattening of a nested data structure into a flat, relational format. Record
assembly is the reconstructing of that shredded structure back into its original nested form.</p>
<p>Below is a visualization of a <em>UserProfile</em> object which has three levels of nesting.</p>
<p><img src="img/bobthebuilder.svg" alt="Example nested data structure">
<em>Figure 1. Visualization of a nested data structure</em></p>
<p>The primitive values appear in the leaf nodes at levels two and three. It is common to use the dot-separated notation to
represent accessing a leaf node value (e.g. <em>preferences.theme</em> = <em>&quot;dark&quot;</em>). The array index notation is used to
represent accessing the individual values in the repeated (array) field like <em>tags</em> (e.g. tags[0] = <em>&quot;builder&quot;</em>, tags
[1] = <em>&quot;diy&quot;</em>).</p>
<p>After shredding the flattened <em>UserProfile</em> value looks like any other row in a relational table. The two array values
in <em>tags</em> are expanded into separate rows. This is similar to using the <em>UNNEST</em> function in SQL which takes the
array value in <em>tags</em> as input, and returns rows for each element in the array.</p>
<table class="col-view">
  <thead>
    <tr>
      <th colspan="5">Flattened UserProfile After Record Shredding</th>
    </tr>
    <tr>
      <th>uid</th>
      <th>displayName</th>
      <th>tags</th>
      <th>preferences.theme</th>
      <th>preferences.notifications</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>9012</td>
      <td>Bob The Builder</td>
      <td>builder</td>
      <td>dark</td>
      <td>false</td>
    </tr>
    <tr>
      <td>9012</td>
      <td>Bob The Builder</td>
      <td>diy</td>
      <td>dark</td>
      <td>false</td>
    </tr>
  </tbody>
</table>
<h2 id="record-assembly" tabindex="-1">Record Assembly <a class="direct-link" href="#record-assembly" aria-hidden="true">#</a></h2>
<p>Next record assembly takes these row values and the column names as input, to fully reconstruct the nested data
structure back to its original form.</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"uid"</span><span class="token operator">:</span> <span class="token string">"9012"</span><span class="token punctuation">,</span><br>  <span class="token property">"displayName"</span><span class="token operator">:</span> <span class="token string">"Bob The Builder"</span><span class="token punctuation">,</span><br>  <span class="token property">"tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token string">"builder"</span><span class="token punctuation">,</span><br>    <span class="token string">"diy"</span><br>  <span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token property">"preferences"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"theme"</span><span class="token operator">:</span> <span class="token string">"dark"</span><span class="token punctuation">,</span><br>    <span class="token property">"notifications"</span><span class="token operator">:</span> <span class="token boolean">false</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>Record assembly also works with just a subset of columns. This is a useful feature which closely matches real-world
usage. Most queries only include a small set of columns relevant to the query. There is no good reason to materialize
the a complete <em>UserProfile</em> if the query requires only parts of it.</p>
<p>If the columns specified in the query are <em>uid</em> and <em>preferences.notifications</em> then record assembly has to read
only these columns. It can skip the remaining columns which are not relevant to the query. The reassembled
<em>UserProfile</em> object preserves its original structure but only contains these fields:</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"uid"</span><span class="token operator">:</span> <span class="token string">"9012"</span><span class="token punctuation">,</span><br>  <span class="token property">"preferences"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"notifications"</span><span class="token operator">:</span> <span class="token boolean">false</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<h2 id="columnar-data-layout" tabindex="-1">Columnar Data Layout <a class="direct-link" href="#columnar-data-layout" aria-hidden="true">#</a></h2>
<p>It is implied above that record shredding and assembly uses a columnar data layout. And this is critical for
reassembly of partial projection from the shredded values in storage. It is an efficient representation because only
the subset of columns required for reassembly have to be scanned.</p>
<p>Typically relational data is associated with row storage. If you access the row (say <em>id</em> = 103) it retrieves all
the related attributes from storage and writes <em>(103, &quot;Eve&quot;, &quot;eavesdropper&quot;)</em> to memory. This matches the access
patterns of transactional applications which needs to read or write a single row or a very small set of rows at a
time. The row storage is optimized for heavy read-write workloads which works on a single row or a very small set of
rows.</p>
<table class="row-view">
  <thead>
    <tr>
      <th colspan="3">Row Format</th>
    </tr>
    <tr>
      <th>id</th>
      <th>username</th>
      <th>role</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>101</td>
      <td>Alice</td>
      <td>sender</td>
    </tr>
    <tr>
      <td>102</td>
      <td>Bob</td>
      <td>receiver</td>
    </tr>
    <tr>
      <td>103</td>
      <td>Eve</td>
      <td>eavesdropper</td>
    </tr>
    <tr>
      <td>104</td>
      <td>Trudy</td>
      <td>intruder</td>
    </tr>
  </tbody>
</table>
<p>The row storage format is not optimized for access patterns of analytical queries. For example to compute the value
of <em>COUNT (DISTINCT role)</em> all data will have to be retrieved from storage, written to memory and scanned to
compute the result. Even though the <em>id</em> and <em>username</em> columns serves no purpose in computing the final result,
they are still materialized into memory from storage. This is unavoidable because row value are stored next to each
other.</p>
<p>If the data is instead stored in a columnar layout, only the <em>role</em> column needs to be scanned to compute the final
result. In this layout the values of a column are stored next to each other.</p>
<table class="col-view">
  <thead>
    <tr>
      <th colspan="3">Columnar Format</th>
    </tr>
    <tr>
      <th>id</th>
      <th>username</th>
      <th>role</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>101</td>
      <td>Alice</td>
      <td>sender</td>
    </tr>
    <tr>
      <td>102</td>
      <td>Bob</td>
      <td>receiver</td>
    </tr>
    <tr>
      <td>103</td>
      <td>Eve</td>
      <td>eavesdropper</td>
    </tr>
    <tr>
      <td>104</td>
      <td>Trudy</td>
      <td>intruder</td>
    </tr>
  </tbody>
</table>
<p>In database terms this optimization is known as <em>projection pushdown</em>. It helps optimize the amount of disk I/O
necessary for scanning data from physical storage.</p>
<h1 id="schema" tabindex="-1">Schema <a class="direct-link" href="#schema" aria-hidden="true">#</a></h1>
<p>The schema is the single source of truth which is used for implementing record shredding and assembly.</p>
<p>A schema is a collection of <em>fields</em>. Each <em>field</em> has a name, a data type and a marker which identifies if the
field is optional or not.</p>
<p>A <em>repeated</em> field is an array of values. The data type can be either a primitive type or even a struct data type. The
order of values is important and is preserved during shredding and reassembly.</p>
<p>A <em>Struct</em> data type adds another level of nesting and contains one or more fields.</p>
<p><img src="img/schema_userprofile.svg" alt="UserProfile Schema">
<em>Figure 2. Schema of UserProfile object</em></p>
<p>The example below (same as Figure 1.) is a valid construction of the <em>UserProfile</em> schema. The <em>preferences.language</em>
property is not present in this instance. In the schema, the <em>language</em> field is marked as an optional field.</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"uid"</span><span class="token operator">:</span> <span class="token string">"9012"</span><span class="token punctuation">,</span><br>  <span class="token property">"displayName"</span><span class="token operator">:</span> <span class="token string">"Bob The Builder"</span><span class="token punctuation">,</span><br>  <span class="token property">"tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token string">"builder"</span><span class="token punctuation">,</span><br>    <span class="token string">"diy"</span><br>  <span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token property">"preferences"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"theme"</span><span class="token operator">:</span> <span class="token string">"dark"</span><span class="token punctuation">,</span><br>    <span class="token property">"notifications"</span><span class="token operator">:</span> <span class="token boolean">false</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>In the next example, the <em>preferences</em> property is not present. In the schema, the <em>preferences</em> field is marked as an
optional field.</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"uid"</span><span class="token operator">:</span> <span class="token string">"1234"</span><span class="token punctuation">,</span><br>  <span class="token property">"displayName"</span><span class="token operator">:</span> <span class="token string">"Alice Wonderland"</span><span class="token punctuation">,</span><br>  <span class="token property">"tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token string">"reader"</span><span class="token punctuation">,</span><br>    <span class="token string">"dreamer"</span><br>  <span class="token punctuation">]</span><br><span class="token punctuation">}</span></code></pre>
<p>In the next example, the <em>preferences.language</em> and <em>preferences.notifications</em> properties are not present. In the
schema both the fields are marked as optional.</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"uid"</span><span class="token operator">:</span> <span class="token string">"5678"</span><span class="token punctuation">,</span><br>  <span class="token property">"displayName"</span><span class="token operator">:</span> <span class="token string">"Chris Coder"</span><span class="token punctuation">,</span><br>  <span class="token property">"tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token string">"developer"</span><span class="token punctuation">,</span><br>    <span class="token string">"python"</span><span class="token punctuation">,</span><br>    <span class="token string">"oss"</span><br>  <span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token property">"preferences"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"theme"</span><span class="token operator">:</span> <span class="token string">"light"</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>The recurring theme here is that by looking at an instance of a nested structure by itself, it is not possible to
identify which properties are missing from it. We need the schema to validate an instance and also know which
properties are not present in it.</p>
<h1 id="the-dremel-encoding" tabindex="-1">The Dremel Encoding <a class="direct-link" href="#the-dremel-encoding" aria-hidden="true">#</a></h1>
<p>A desirable property of record shredding is that it should not inflate the size of the stored nested data structure.
If the shredded encoding ended up being smaller than directly storing the nested data structure itself, that will
be a great win.</p>
<p>The abstract representation of record shredding introduced in the beginning is not well-designed. The most obvious
issue is the data redundancy required for the <em>tags</em> repeated field. The number of rows in this representation
depends on the cardinality (number of elements) of the <em>tags</em> property.</p>
<p>Also to keep complexity low without sacrificing the essence of how record shredding works we deliberately did not tackle
the problem of how missing properties should be represented.</p>
<p>The three examples of <em>UserProfile</em> from above after shredding using the Dremel technique is represented as shown below.</p>
<table class="col-view">
  <thead>
    <tr>
      <th colspan="5">Dremel Encoding</th>
    </tr>
    <tr>
      <th>uid</th>
      <th>displayName</th>
      <th>tags</th>
      <th>preferences.theme</th>
      <th>preferences.notifications</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1234</td>
      <td>Alice Wonderland</td>
      <td>reader</td>
      <td>light</td>
      <td>false</td>
    </tr>
    <tr>
      <td>5678</td>
      <td>Chris Coder</td>
      <td>dreamer</td>
      <td>dark</td>
      <td></td>
    </tr>
    <tr>
      <td>9012</td>
      <td>Bob The Builder</td>
      <td>developer</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>python</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>oss</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>builder</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>diy</td>
      <td></td>
      <td></td>
    </tr>
  </tbody>
</table>
<p>This representation wastes no space for representing properties which are missing in the values. The cardinality of
a repeated field like <em>tags</em> has no effect on other columns. This representation ends up taking less space than
directly storing the <em>UserProfile</em> objects.</p>
<p>But they do not line up nicely into rows which informs you where a record begins and ends just by visual inspection.
So if you are thinking there is not enough information here to be able to reassemble the original values, you are on
the right track.</p>
<h2 id="structure-is-metadata" tabindex="-1">Structure is Metadata <a class="direct-link" href="#structure-is-metadata" aria-hidden="true">#</a></h2>
<p>A schema definition leads to a variety of possible structures. This can be seen in the below visualization of the three
<em>UserProfile</em> examples introduced earlier. Without the distraction of labels, we can look at the structure by itself.</p>
<p><img src="img/structure_userprofile.svg" alt="Tree node illustration of UserProfile objects">
<em>Figure 3. Structure of UserProfile Objects</em></p>
<p>What causes the structural variability?</p>
<p>If any of the optional fields are not present, or if a repeated (array) field is empty it manifests as a hole in the
structure. The cardinality of the repeated field also modifies the structure.</p>
<p>The key insight in Dremel encoding is to distill both these sources of structural variability into a computed
numeric value during the process of record shredding. By interpreting the values extracted from the leaf nodes
together with the two derived metadata values the original nested data structure can be reassembled.</p>
<p>In Dremel these metadata columns are known as <em>definition levels</em> and <em>repetition levels</em>.</p>
<h1 id="how-definition-levels-work" tabindex="-1">How Definition Levels Work <a class="direct-link" href="#how-definition-levels-work" aria-hidden="true">#</a></h1>
<p>Consider a single nested path of interleaving optional and repeated fields. The definition level is computed by
counting the optional fields which are present, and the repeated fields which are present and not empty.</p>
<p><img src="img/example_def_levels.svg" alt="Annotated definition levels for path with interleaving optional and repeated fields">
<em>Figure 4. Annotated definition levels for a nested path</em></p>
<p>The example path <em>a.b.c.d.e</em> shown above contains three optional fields and two repeated fields. The definition
levels for this path will be in the range (inclusive) [0, 5]. The calculation is simple. If a field is present then
we increment the definition level count. We continue doing this for each optional and repeated field until the path
terminates. The final count tell us exact point at which a path terminates.</p>
<p>In this example a definition level of zero indicates that the path is not present in the data instance. If a path
defined in the schema contains only required fields then the definition levels will be always zero for all values.
In this case we do not need to compute or store the definition levels. For example, the <em>uid</em> is a required field in
the <em>UserProfile</em> schema. We can simply skip computing definition levels as there are no optional or repeated fields
in this path.</p>
<table>
  <thead>
    <tr>
      <th>No.</th>
      <th>Path</th>
      <th>Definition Level</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Ã˜</td>
      <td>0</td>
      <td>Empty path. The field <em>a</em> is not present.</td>
    </tr>
    <tr>
      <td>2</td>
      <td>a</td>
      <td>1</td>
      <td>The repeated field <em>b</em> is empty and not present.</td>
    </tr>
    <tr>
      <td>3</td>
      <td>a.b</td>
      <td>2</td>
      <td>The optional field <em>c</em> is not present.</td>
    </tr>
    <tr>
      <td>4.</td>
      <td>a.b.c</td>
      <td>3</td>
      <td>The repeated field <em>d</em> is not present.</td>
    </tr>
    <tr>
      <td>5</td>
      <td>a.b.c.d</td>
      <td>4</td>
      <td>The optional field <em>e</em> is not present.</td>
    </tr>
    <tr>
      <td>6.</td>
      <td>a.b.c.d.e</td>
      <td>5</td>
      <td>All the fields in this path are present.</td>
    </tr>
  </tbody>
</table>
<h1 id="how-repetition-levels-work" tabindex="-1">How Repetition Levels Work <a class="direct-link" href="#how-repetition-levels-work" aria-hidden="true">#</a></h1>
<p>The computation of repetition levels is complicated relative to definition levels.</p>
<p>The repetition level is a count of the repeated fields in path. The <em>n<sup>th</sup></em> repeated field has a repetition
level of <em>n</em>. Non-repeated fields contribute to overall nesting of the structure but does not increment the
repetition level count.</p>
<p>To demarcate the beginning of a new list the first element inherits the repetition level of its parent repeated
field. The subsequent elements in the list have a repetition level equal to the repeated field.</p>
<p>The first repeated field has a repetition level of one. But it does not have a parent. So the repetition level of
the first element is chosen to be zero. This is a special case. If the data type of the first repeated field is
non-primitive, then the first element in the nested repeated field will inherit the repetition level value of zero.
This is repeated for additional levels of nesting.</p>
<p>The zero repetition level therefore is valuable in identifying record boundaries. It indicates the start of a new
record.</p>
<h2 id="how-repetition-levels-capture-nested-structure" tabindex="-1">How Repetition Levels Capture Nested Structure <a class="direct-link" href="#how-repetition-levels-capture-nested-structure" aria-hidden="true">#</a></h2>
<p>All three examples in Figure 5. have the same sequence of values but the nested list structure is different in each
case. By working through this example it will become evident how repetition levels correctly encodes the different
structures making it possible to correctly reassemble the original nested data structure.</p>
<p><img src="img/example_1_rep_levels.svg" alt="Repeated field with same value sequence but different arrangements">
<em>Figure 5. Nested repeated fields with similar values but different structures</em></p>
<p>Let us begin with <em>Record 1</em> and for improved readability substitute the inner lists with variable names <em>x</em> and <em>y</em>.</p>
<p><em>[x, y]</em></p>
<p>The goal here is to compute the repetition levels for <em>x</em> and <em>y</em> in the first repeated field.</p>
<table>
  <thead>
    <tr><th colspan="4">Outer List</th></tr>
    <tr>
      <th>Variable Name</th>
      <th>Value</th>
      <th>Repetition Level</th>
      <th>Reason</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>x</td>
      <td>[1, 2, 3]</td>
      <td>0</td>
      <td>Beginning of a new record.</td>
    </tr>
    <tr>
      <td>y</td>
      <td>[4, 5, 6]</td>
      <td>1</td>
      <td>Same as repetition level of outer list.</td>
    </tr>
  </tbody>
</table>
<p>Next let us proceed with calculating the repetition levels for <em>x</em> (first inner list).</p>
<table>
  <thead>
    <tr><th colspan="3">First Inner List (x)</th></tr>
    <tr>
      <th>Value</th>
      <th>Repetition Level</th>
      <th>Reason</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>First element inherits repetition level of parent (see x)</td>
    </tr>
    <tr>
      <td>2</td>
      <td>2</td>
      <td>Same as repetition level of inner list which is the second repeated field.</td>
    </tr>
    <tr>
      <td>3</td>
      <td>2</td>
      <td>Same as repetition level of inner list which is the second repeated field.</td>
    </tr>
  </tbody>
</table>
<p>Similar line of reason applies for the next element <em>y</em> (second inner list).</p>
<table>
  <thead>
    <tr><th colspan="3">Second Inner List (y)</th></tr>
    <tr>
      <th>Value</th>
      <th>Repetition Level</th>
      <th>Reason</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>4</td>
      <td>1</td>
      <td>First element inherits repetition level of parent (see y)</td>
    </tr>
    <tr>
      <td>5</td>
      <td>2</td>
      <td>Same as repetition level of inner list which is the second repeated field.</td>
    </tr>
    <tr>
      <td>6</td>
      <td>2</td>
      <td>Same as repetition level of inner list which is the second repeated field.</td>
    </tr>
  </tbody>
</table>
<p>Merging both the tables we get.</p>
<table>
  <caption>Final Result</caption>
  <tbody>
    <tr>
      <th>Value</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
    </tr>
    <tr>
      <th>Repetition Level</th>
      <td>0</td>
      <td>2</td>
      <td>2</td>
      <td>1</td>
      <td>2</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
<p>This is the final computed repetition levels for all three examples. You are free to check the results yourself.</p>
<table>
  <caption>Repetition Levels</caption>
  <tbody>
    <tr>
      <th>values</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
    </tr>
    <tr>
      <th>Record 1</th>
      <td>0</td>
      <td>2</td>
      <td>2</td>
      <td>1</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <th>Record 2</th>
      <td>0</td>
      <td>2</td>
      <td>1</td>
      <td>2</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>Record 3</th>
      <td>0</td>
      <td>2</td>
      <td>1</td>
      <td>2</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <th>definition levels</th>
      <td>2</td>
      <td>2</td>
      <td>2</td>
      <td>2</td>
      <td>2</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
<p>The definition levels is identical for all three records and not useful for learning about the structure of the
records. However, the repetition levels vary for each record. We can distinctly identify the start of a new record
with by zero repetition level. The start of new list within a record is identifiable by the change in repetition level.</p>
<h2 id="when-a-repeated-field-is-empty" tabindex="-1">When a repeated field is empty <a class="direct-link" href="#when-a-repeated-field-is-empty" aria-hidden="true">#</a></h2>
<p>This record shredding walk through will show how both definition and repetition levels are interpreted together to
identify empty repeated fields.</p>
<p><em>Record 1</em>: [ [1, 2], [], [3] ]</p>
<p><em>Record 2</em>: [ [], [4, 5, 6], []]</p>
<p>Let us begin with <em>Record 1</em> and like earlier substitute the inner lists with variable names: <em>x</em>, <em>y</em> and <em>z</em>.</p>
<table>
<thead>
<tr>
<th>Variable Name</th>
<th>Value</th>
<th>Def</th>
<th>Rep</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>[1, 2]</td>
<td>1</td>
<td>0</td>
<td>Def=1, first repeated field (outer list). <br/>Rep=0, beginning of a new record</td>
</tr>
<tr>
<td>y</td>
<td>[]</td>
<td>1</td>
<td>1</td>
<td>Rep=1, same as repetition level of repeated field (outer list)</td>
</tr>
<tr>
<td>z</td>
<td>[3]</td>
<td>1</td>
<td>1</td>
<td>Same as above.</td>
</tr>
</tbody>
</table>
<p>Let us now continue with <em>Record 2</em>. Like earlier let us substitute the inner lists with variable names: <em>p</em>, <em>q</em>
and <em>r</em>.</p>
<table>
<thead>
<tr>
<th>Variable Name</th>
<th>Value</th>
<th>Def</th>
<th>Rep</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>[]</td>
<td>1</td>
<td>0</td>
<td>Def=1, first repeated field (outer list). <br/>Rep=0, beginning of a new record</td>
</tr>
<tr>
<td>q</td>
<td>[4,5,6]</td>
<td>1</td>
<td>1</td>
<td>Rep=1, same as repetition level of repeated field (outer list)</td>
</tr>
<tr>
<td>r</td>
<td>[]</td>
<td>1</td>
<td>1</td>
<td>Same as above.</td>
</tr>
</tbody>
</table>
<p>Next let us process all the inner list elements in both records.</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Def</th>
<th>Rep</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>0</td>
<td>Def=2, second repeated field.<br/> Rep=0, Inherited from parent (outer list) because this is the first element (see x).</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>2</td>
<td>Rep=2, same as repetition level of repeated field (inner list)</td>
</tr>
<tr>
<td>NULL</td>
<td>1</td>
<td>1</td>
<td>Def=1, as inner list is empty (see y). Rep=1, Same as final non-empty repeated field (outer list)</td>
</tr>
<tr>
<td>NULL</td>
<td>1</td>
<td>0</td>
<td>Def=1, inner list is empty (see p). Rep=0, Inherited from parent (outer list) because this is the first element (see p).</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>2</td>
<td>Def=2, second repeated field. <br/> Rep=2, same as repetition level of repeated field (inner list)</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>2</td>
<td>Same as above.</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
<td>2</td>
<td>Same as above.</td>
</tr>
<tr>
<td>NULL</td>
<td>1</td>
<td>1</td>
<td>Def=1, inner list is empty (see r). Rep=1, same as final non-empty repeated field (outer list)</td>
</tr>
</tbody>
</table>
<p>In the physical representation the NULL values do not have to be stored.</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Value</strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"><strong>Def</strong></td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:left"><strong>Rep</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>During record assembly the NULL value or empty repeated field can be inferred by interpreting the definition levels
together with the repetition levels.</p>
<p>In this example the definition level is 1 after the value 2. The repetition level is not zero. This tells us that we
are still within the outer list of the first record, but this is an empty list. So even without physically storing
the NULL value we can infer its presence and recreate the empty list inside <em>Record 1</em>.</p>
<p>The next definition level is again 1, but the repetition level has now changed to zero. This tell us that a new
record has started, but the first inner list element is empty. This matches the original structure of <em>Record 2</em>.</p>
<h1 id="conclusion" tabindex="-1">Conclusion <a class="direct-link" href="#conclusion" aria-hidden="true">#</a></h1>


    </main>

    <footer></footer>

    <!-- Current page: /posts/2025-06-06-record-shredding-part-1/ -->
  </body>
</html>
