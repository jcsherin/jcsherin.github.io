<style>
th, td {
  text-align: center;
  vertical-align: top;
  padding: 8px 16px;
}

.table-container {
  display: flex;
  justify-content: space-around;
  gap: 20px;
}

.col-view td:nth-child(1), .col-view th:nth-child(1):not([colspan]) { background-color: #FFFFE0; }
.col-view td:nth-child(2), .col-view th:nth-child(2) { background-color: #FFDAB9; }
.col-view td:nth-child(3), .col-view th:nth-child(3) { background-color: #E6E6FA; }
.col-view td:nth-child(4), .col-view th:nth-child(4) { background-color: #DDFADD; }
.col-view td:nth-child(5), .col-view th:nth-child(5) { background-color: #F0F8FF; }

.row-view tr:nth-child(1) td { background-color: #FFFFE0; }
.row-view tr:nth-child(2) td { background-color: #FFDAB9; }
.row-view tr:nth-child(3) td { background-color: #E6E6FA; }
.row-view tr:nth-child(4) td { background-color: #DDFADD; }

.col-view {
  border-spacing: 8px 0;
}

.row-view {
  border-spacing: 0 8px;
}

.record-container {
  display: flex;
}

.default-value {
  color: #555555;
}

/* to be removed later */
body {
  max-width: 800px;
  font-size: 20px;
  margin: 0 auto 220px;
}
</style>
<h1 id="introduction" tabindex="-1">Introduction <a class="direct-link" href="#introduction" aria-hidden="true">#</a></h1>
<p><em>To be filled in later.</em></p>
<h1 id="record-shredding-and-assembly" tabindex="-1">Record Shredding And Assembly <a class="direct-link" href="#record-shredding-and-assembly" aria-hidden="true">#</a></h1>
<p>Conceptually, record shredding is a flattening of a nested data structure into a flat, relational format. Record
assembly is the reconstructing of that shredded structure back into its original nested form.</p>
<p>Below is a visualization of a <em>UserProfile</em> object which has three levels of nesting.</p>
<p><img src="img/bobthebuilder.svg" alt="Example nested data structure">
<em>Figure 1. Visualization of a nested data structure</em></p>
<p>The primitive values appear in the leaf nodes at levels two and three. It is common to use the dot-separated notation to
represent accessing a leaf node value (e.g. <em>preferences.theme</em> = <em>&quot;dark&quot;</em>). The array index notation is used to
represent accessing the individual values in the repeated (array) field like <em>tags</em> (e.g. tags[0] = <em>&quot;builder&quot;</em>, tags
[1] = <em>&quot;diy&quot;</em>).</p>
<p>After shredding the flattened <em>UserProfile</em> value looks like any other row in a relational table. The two array values
in <em>tags</em> are expanded into separate rows. This is similar to using the <em>UNNEST</em> function in SQL which takes the
array value in <em>tags</em> as input, and returns rows for each element in the array.</p>
<table class="col-view">
  <thead>
    <tr>
      <th colspan="5">Flattened UserProfile After Record Shredding</th>
    </tr>
    <tr>
      <th>uid</th>
      <th>displayName</th>
      <th>tags</th>
      <th>preferences.theme</th>
      <th>preferences.notifications</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>9012</td>
      <td>Bob The Builder</td>
      <td>builder</td>
      <td>dark</td>
      <td>false</td>
    </tr>
    <tr>
      <td>9012</td>
      <td>Bob The Builder</td>
      <td>diy</td>
      <td>dark</td>
      <td>false</td>
    </tr>
  </tbody>
</table>
<h2 id="record-assembly" tabindex="-1">Record Assembly <a class="direct-link" href="#record-assembly" aria-hidden="true">#</a></h2>
<p>Next record assembly takes these row values and the column names as input, to fully reconstruct the nested data
structure back to its original form.</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"uid"</span><span class="token operator">:</span> <span class="token string">"9012"</span><span class="token punctuation">,</span><br>  <span class="token property">"displayName"</span><span class="token operator">:</span> <span class="token string">"Bob The Builder"</span><span class="token punctuation">,</span><br>  <span class="token property">"tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token string">"builder"</span><span class="token punctuation">,</span><br>    <span class="token string">"diy"</span><br>  <span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token property">"preferences"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"theme"</span><span class="token operator">:</span> <span class="token string">"dark"</span><span class="token punctuation">,</span><br>    <span class="token property">"notifications"</span><span class="token operator">:</span> <span class="token boolean">false</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>Record assembly also works with just a subset of columns. This is a useful feature which closely matches real-world
usage. Most queries only include a small set of columns relevant to the query. There is no good reason to materialize
the a complete <em>UserProfile</em> if the query requires only parts of it.</p>
<p>If the columns specified in the query are <em>uid</em> and <em>preferences.notifications</em> then record assembly has to read
only these columns. It can skip the remaining columns which are not relevant to the query. The reassembled
<em>UserProfile</em> object preserves its original structure but only contains these fields:</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"uid"</span><span class="token operator">:</span> <span class="token string">"9012"</span><span class="token punctuation">,</span><br>  <span class="token property">"preferences"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"notifications"</span><span class="token operator">:</span> <span class="token boolean">false</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<h2 id="columnar-data-layout" tabindex="-1">Columnar Data Layout <a class="direct-link" href="#columnar-data-layout" aria-hidden="true">#</a></h2>
<p>It is implied above that record shredding and assembly uses a columnar data layout. And this is critical for
reassembly of partial projection from the shredded values in storage. It is an efficient representation because only
the subset of columns required for reassembly have to be scanned.</p>
<p>Typically relational data is associated with row storage. If you access the row (say <em>id</em> = 103) it retrieves all
the related attributes from storage and writes <em>(103, &quot;Eve&quot;, &quot;eavesdropper&quot;)</em> to memory. This matches the access
patterns of transactional applications which needs to read or write a single row or a very small set of rows at a
time. The row storage is optimized for heavy read-write workloads which works on a single row or a very small set of
rows.</p>
<table class="row-view">
  <thead>
    <tr>
      <th colspan="3">Row Format</th>
    </tr>
    <tr>
      <th>id</th>
      <th>username</th>
      <th>role</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>101</td>
      <td>Alice</td>
      <td>sender</td>
    </tr>
    <tr>
      <td>102</td>
      <td>Bob</td>
      <td>receiver</td>
    </tr>
    <tr>
      <td>103</td>
      <td>Eve</td>
      <td>eavesdropper</td>
    </tr>
    <tr>
      <td>104</td>
      <td>Trudy</td>
      <td>intruder</td>
    </tr>
  </tbody>
</table>
<p>The row storage format is not optimized for access patterns of analytical queries. For example to compute the value
of <em>COUNT (DISTINCT role)</em> all data will have to be retrieved from storage, written to memory and scanned to
compute the result. Even though the <em>id</em> and <em>username</em> columns serves no purpose in computing the final result,
they are still materialized into memory from storage. This is unavoidable because row value are stored next to each
other.</p>
<p>If the data is instead stored in a columnar layout, only the <em>role</em> column needs to be scanned to compute the final
result. In this layout the values of a column are stored next to each other.</p>
<table class="col-view">
  <thead>
    <tr>
      <th colspan="3">Columnar Format</th>
    </tr>
    <tr>
      <th>id</th>
      <th>username</th>
      <th>role</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>101</td>
      <td>Alice</td>
      <td>sender</td>
    </tr>
    <tr>
      <td>102</td>
      <td>Bob</td>
      <td>receiver</td>
    </tr>
    <tr>
      <td>103</td>
      <td>Eve</td>
      <td>eavesdropper</td>
    </tr>
    <tr>
      <td>104</td>
      <td>Trudy</td>
      <td>intruder</td>
    </tr>
  </tbody>
</table>
<p>In database terms this optimization is known as <em>projection pushdown</em>. It helps optimize the amount of disk I/O
necessary for scanning data from physical storage.</p>
<h1 id="schema" tabindex="-1">Schema <a class="direct-link" href="#schema" aria-hidden="true">#</a></h1>
<p>The schema is the single source of truth which is used for implementing record shredding and assembly.</p>
<p>A schema is a collection of <em>fields</em>. Each <em>field</em> has a name, a data type and a marker which identifies if the
field is optional or not.</p>
<p>A <em>repeated</em> field is an array of values. The data type can be either a primitive type or even a struct data type. The
order of values is important and is preserved during shredding and reassembly.</p>
<p>A <em>Struct</em> data type adds another level of nesting and contains one or more fields.</p>
<p><img src="img/schema_userprofile.svg" alt="UserProfile Schema">
<em>Figure 2. Schema of UserProfile object</em></p>
<p>The example below (same as Figure 1.) is a valid construction of the <em>UserProfile</em> schema. The <em>preferences.language</em>
property is not present in this instance. In the schema, the <em>language</em> field is marked as an optional field.</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"uid"</span><span class="token operator">:</span> <span class="token string">"9012"</span><span class="token punctuation">,</span><br>  <span class="token property">"displayName"</span><span class="token operator">:</span> <span class="token string">"Bob The Builder"</span><span class="token punctuation">,</span><br>  <span class="token property">"tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token string">"builder"</span><span class="token punctuation">,</span><br>    <span class="token string">"diy"</span><br>  <span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token property">"preferences"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"theme"</span><span class="token operator">:</span> <span class="token string">"dark"</span><span class="token punctuation">,</span><br>    <span class="token property">"notifications"</span><span class="token operator">:</span> <span class="token boolean">false</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>In the next example, the <em>preferences</em> property is not present. In the schema, the <em>preferences</em> field is marked as an
optional field.</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"uid"</span><span class="token operator">:</span> <span class="token string">"1234"</span><span class="token punctuation">,</span><br>  <span class="token property">"displayName"</span><span class="token operator">:</span> <span class="token string">"Alice Wonderland"</span><span class="token punctuation">,</span><br>  <span class="token property">"tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token string">"reader"</span><span class="token punctuation">,</span><br>    <span class="token string">"dreamer"</span><br>  <span class="token punctuation">]</span><br><span class="token punctuation">}</span></code></pre>
<p>In the next example, the <em>preferences.language</em> and <em>preferences.notifications</em> properties are not present. In the
schema both the fields are marked as optional.</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"uid"</span><span class="token operator">:</span> <span class="token string">"5678"</span><span class="token punctuation">,</span><br>  <span class="token property">"displayName"</span><span class="token operator">:</span> <span class="token string">"Chris Coder"</span><span class="token punctuation">,</span><br>  <span class="token property">"tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token string">"developer"</span><span class="token punctuation">,</span><br>    <span class="token string">"python"</span><span class="token punctuation">,</span><br>    <span class="token string">"oss"</span><br>  <span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token property">"preferences"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"theme"</span><span class="token operator">:</span> <span class="token string">"light"</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>The recurring theme here is that by looking at an instance of a nested structure by itself, it is not possible to
identify which properties are missing from it. We need the schema to validate an instance and also know which
properties are not present in it.</p>
<h1 id="the-dremel-encoding" tabindex="-1">The Dremel Encoding <a class="direct-link" href="#the-dremel-encoding" aria-hidden="true">#</a></h1>
<p>A desirable property of record shredding is that it should not inflate the size of the stored nested data structure.
If the shredded encoding ended up being smaller than directly storing the nested data structure itself, that will
be a great win.</p>
<p>The abstract representation of record shredding introduced in the beginning is not well-designed. The most obvious
issue is the data redundancy required for the <em>tags</em> repeated field. The number of rows in this representation
depends on the cardinality (number of elements) of the <em>tags</em> property.</p>
<p>Also to keep complexity low without sacrificing the essence of how record shredding works we deliberately did not tackle
the problem of how missing properties should be represented.</p>
<p>The three examples of <em>UserProfile</em> from above after shredding using the Dremel technique is represented as shown below.</p>
<table class="col-view">
  <thead>
    <tr>
      <th colspan="5">Dremel Encoding</th>
    </tr>
    <tr>
      <th>uid</th>
      <th>displayName</th>
      <th>tags</th>
      <th>preferences.theme</th>
      <th>preferences.notifications</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1234</td>
      <td>Alice Wonderland</td>
      <td>reader</td>
      <td>light</td>
      <td>false</td>
    </tr>
    <tr>
      <td>5678</td>
      <td>Chris Coder</td>
      <td>dreamer</td>
      <td>dark</td>
      <td></td>
    </tr>
    <tr>
      <td>9012</td>
      <td>Bob The Builder</td>
      <td>developer</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>python</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>oss</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>builder</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>diy</td>
      <td></td>
      <td></td>
    </tr>
  </tbody>
</table>
<p>This representation wastes no space for representing properties which are missing in the values. The cardinality of
a repeated field like <em>tags</em> has no effect on other columns. This representation ends up taking less space than
directly storing the <em>UserProfile</em> objects.</p>
<p>But they do not line up nicely into rows which informs you where a record begins and ends just by visual inspection.
So if you are thinking there is not enough information here to be able to reassemble the original values, you are on
the right track.</p>
<h2 id="structure-is-data" tabindex="-1">Structure is Data <a class="direct-link" href="#structure-is-data" aria-hidden="true">#</a></h2>
<p>The key insight from the Dremel encoding is in recognizing that the structure of nested data structure is also a
part of the shredded representation.</p>
<p>The <em>UserProfile</em> schema (see Figure 2) contains five optional fields, and one repeated field. An optional field is
a property which may or may not be present in a data instance. A repeated field maybe empty or contain any number of
elements.</p>
<p>So a single schema definition can lead to a variety of structures as shown below.</p>
<p><img src="img/structure_userprofile.svg" alt="Tree node illustration of UserProfile objects">
<em>Figure 3. Structure of UserProfile Objects</em></p>
<p>The elegance of the Dremel encoding is in how it is able to represent any structure which can arise from a schema
with just two computed numeric values. The first metadata tracks the presence of optional fields in a data instance
and is known as definition levels. The second metadata is related to the elements which are part of repeated (array)
fields and is known as repetition levels.</p>
<hr>
<p>Pending:</p>
<ul>
<li>Repetition levels are complicated</li>
<li>Definition levels are simple</li>
<li>Show <em>tags</em> with definition, repetition levels</li>
<li>Conclusion</li>
<li>Introduction</li>
</ul>
