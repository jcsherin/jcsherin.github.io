<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forged in Practice: How Implementing Window Functions Refined DataFusion&#39;s API</title>
    <meta name="description" content="jcsherin writes about programming">
    <meta name="generator" content="Eleventy v1.0.1">

    <link rel="stylesheet" href="/css/index.css">
    <link rel="stylesheet" href="/css/prism-base16-monokai.dark.css">
    <link rel="stylesheet" href="/css/prism-diff.css">
    <link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="jcsherin">
    <link rel="alternate" href="/feed/feed.json" type="application/json" title="jcsherin">
  </head>
  <body>
    <div class="page-wrapper">
      <header>
        <h1 class="home"><a href="/">jcsherin</a></h1>
        <ul class="nav">
          <li class="nav-item"><a href="/">Writings</a></li>
          <li class="nav-item"><a href="/about/">About</a></li>
        </ul>
      </header>

      <main class="tmpl-post">
        <h1>Forged in Practice: How Implementing Window Functions Refined DataFusion&#39;s API</h1>

<time datetime="2025-06-17">17 Jun 2025</time>


  <div class="draft-indicator">
    <p><strong>DRAFT</strong></p>
    <p>This is a draft preview. To publish, remove draft: true from the front matter.</p>
  </div>


<p>Designing a library's core abstractions is one of the most challenging parts of software engineering. It's a balancing
act between simplicity, power, and future-proofing. But as we found during a major refactor in Apache DataFusion, the
best APIs aren't just designedâ€”they're forged and refined in the fire of real-world implementation.</p>
<p>This post is a case study of that process. We'll trace the evolution of the <code>WindowUDFImpl</code> trait, showing how its
initial design was stress-tested and ultimately improved by the practical requirements of converting complex window
functions like <code>LEAD</code> and <code>LAG</code>.</p>
<h3 id="the-starting-point:-a-clean-but-simple-abstraction" tabindex="-1">The Starting Point: A Clean but Simple Abstraction <a class="direct-link" href="#the-starting-point:-a-clean-but-simple-abstraction" aria-hidden="true">#</a></h3>
<p>The DataFusion community had a clear strategic goal: unify the two separate function interfaces (<code>BuiltInWindowFunction</code>
and <code>WindowUDF</code>) into a single, trait-based API. Building on the success of a similar refactor for scalar functions, the
initial <code>WindowUDFImpl</code> trait was designed for clarity and simplicity, and it served as a solid architectural blueprint.</p>
<p><em>(Here, you can show the initial, simpler version of the <code>WindowUDFImpl</code> trait, highlighting methods like <code>return_type</code>
and <code>nullable</code>.)</em></p>
<h3 id="the-challenge:-applying-the-blueprint-to-a-new-domain" tabindex="-1">The Challenge: Applying the Blueprint to a New Domain <a class="direct-link" href="#the-challenge:-applying-the-blueprint-to-a-new-domain" aria-hidden="true">#</a></h3>
<p>With a proven pattern from the scalar function refactor, the next challenge was to adapt and apply this blueprint to the
more complex domain of window functions. My work began here: taking the core ideas and being the first to prove them out
on the windowing engine, which had its own unique requirements for stateful evaluation and optimizer integration.</p>
<h3 id="the-first-test:-a-successful-row_number-conversion" tabindex="-1">The First Test: A Successful <code>row_number</code> Conversion <a class="direct-link" href="#the-first-test:-a-successful-row_number-conversion" aria-hidden="true">#</a></h3>
<p>The first candidate for this new approach was <code>row_number</code>. As a simple function with no arguments and a fixed return
type, it was the perfect vehicle to validate that the core pattern was sound. The conversion was a success and
demonstrated the viability of the unification effort.</p>
<p><em>(Here, you can briefly show the clean implementation of <code>WindowUDFImpl</code> for <code>row_number</code> and how it mapped well to the
initial trait design.)</em></p>
<h3 id="hitting-the-limits:-the-challenge-of-lead-and-lag" tabindex="-1">Hitting the Limits: The Challenge of <code>LEAD</code> and <code>LAG</code> <a class="direct-link" href="#hitting-the-limits:-the-challenge-of-lead-and-lag" aria-hidden="true">#</a></h3>
<p>The real test came when we moved on to more complex functions. The simple API immediately presented several difficult
questions that it was not yet equipped to answer:</p>
<ol>
<li><strong>How can the query optimizer know that <code>LEAD</code> is the semantic inverse of <code>LAG</code>?</strong> This is crucial for performance.</li>
<li><strong>How can a function's return type be determined when it depends on multiple, potentially <code>NULL</code>, arguments?</strong></li>
<li><strong>How can the stateful <code>PartitionEvaluator</code> access the literal values of its arguments to configure its behavior?</strong></li>
</ol>
<p>It became clear that to implement these functions correctly, the API itself had to evolve.</p>
<h3 id="reforging-the-api:-the-introduction-of-field-reverse_expr-and-partitionevaluatorargs" tabindex="-1">Reforging the API: The Introduction of <code>field</code>, <code>reverse_expr</code>, and <code>PartitionEvaluatorArgs</code> <a class="direct-link" href="#reforging-the-api:-the-introduction-of-field-reverse_expr-and-partitionevaluatorargs" aria-hidden="true">#</a></h3>
<p>This led to a series of patches that fundamentally improved the <code>WindowUDFImpl</code> trait, driven directly by the problems
we discovered during implementation.</p>
<p><em>(This is your core technical section. Use your patches to show the &quot;before&quot; and &quot;after&quot; for each of these API
additions, explaining what problem each one solved.)</em></p>
<ul>
<li><strong>The <code>field</code> Method:</strong> Show how this replaced <code>return_type</code> and <code>nullable</code>, giving the implementer more context.</li>
<li><strong>The <code>reverse_expr</code> Method:</strong> Explain how this provided a formal hook for the query optimizer.</li>
<li><strong>The <code>PartitionEvaluatorArgs</code> struct:</strong> Detail how this gave the stateful evaluator crucial information from the
physical plan.</li>
</ul>
<h3 id="the-payoff:-an-elegant-implementation" tabindex="-1">The Payoff: An Elegant Implementation <a class="direct-link" href="#the-payoff:-an-elegant-implementation" aria-hidden="true">#</a></h3>
<p>With the new, more expressive API in place, the implementation of <code>LEAD</code> and <code>LAG</code> became straightforward and robust,
proving the value of the iterative design process.</p>
<p><em>(Here, you can show snippets from the final <code>lead_lag.rs</code> implementation, highlighting how it elegantly uses the new
API methods.)</em></p>
<h3 id="lessons-learned-on-api-design-and-community" tabindex="-1">Lessons Learned on API Design and Community <a class="direct-link" href="#lessons-learned-on-api-design-and-community" aria-hidden="true">#</a></h3>
<p>This journey offers several valuable lessons that extend beyond just DataFusion:</p>
<ul>
<li><strong>Start with a simple abstraction, but stress-test it immediately</strong> with your most complex use cases.</li>
<li><strong>Treat implementation feedback as a core part of the design process.</strong> When an abstraction feels clumsy or limiting,
it's an opportunity to improve it.</li>
<li><strong>Good architecture enables community.</strong> A well-designed, repeatable pattern doesn't just make the original author's
life easier; it creates a &quot;paved path&quot; for new contributors. The clarity of the final <code>WindowUDF</code> trait made it
possible to file well-defined &quot;good first issues,&quot; broadening the base of community involvement and turning a large
solo effort into a parallelizable community one.</li>
</ul>


      </main>

      <footer></footer>

      <!-- Current page: /posts/2025-06-17-implementing-datafusion-udwf-api/ -->
    </body>
  </div>
</html>
