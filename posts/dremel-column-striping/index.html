<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nested Record Shredding</title>
    <meta name="description" content="Shredding nested data for columnar storage">
    <meta name="generator" content="Eleventy v1.0.1">

    <link rel="stylesheet" href="/css/index.css">
    <link rel="stylesheet" href="/css/prism-base16-monokai.dark.css">
    <link rel="stylesheet" href="/css/prism-diff.css">
    <link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="jcsherin">
    <link rel="alternate" href="/feed/feed.json" type="application/json" title="jcsherin">
  </head>
  <body>
    <header>
      <h1 class="home"><a href="/">jcsherin</a></h1>
      <ul class="nav">
        <li class="nav-item"><a href="/">Home</a></li>
        <li class="nav-item"><a href="/posts/">Archive</a></li>
        <li class="nav-item"><a href="/about/">About Me</a></li>
      </ul>
    </header>

    <main class="tmpl-post">
      <h1>Nested Record Shredding</h1>

<time datetime="2025-04-21">21 Apr 2025</time><a href="/tags/record-shredding/" class="post-tag">record shredding</a><a href="/tags/column-striping/" class="post-tag">column striping</a><a href="/tags/nested-data/" class="post-tag">nested data</a>

<h1 id="introduction" tabindex="-1">Introduction <a class="direct-link" href="#introduction" aria-hidden="true">#</a></h1>
<p>The main issue with flattening nested data structures is ensuring the<br>
process is reversible. The flattened representation needs to contain both data<br>
and the metadata which encodes the structure. From this representation, one<br>
should be able to correctly reconstruct the original nested data structure.</p>
<p>Typically, a query reads only a few attributes. Therefore, it is more<br>
efficient to read only those specific attributes, rather than the entire<br>
nested data structure. Consequently, a core desirable property of<br>
such flattening is the ability to partially reconstruct the nested data<br>
structure, skipping any attributes not mentioned in the query.</p>
<ul>
<li>[ ] <strong>TODO:</strong> Create illustration for partial projection
<ul>
<li><strong>Objective:</strong> Original and partial side by side</li>
<li><strong>Details</strong>:
<ul>
<li><strong>Original</strong>
<ul>
<li>Clear, compact (YAML over JSON)</li>
<li>Example has 2 or more levels of nesting</li>
<li>Clearly labelled as original</li>
</ul>
</li>
<li><strong>Partial Projection</strong>
<ul>
<li>Briefly state the query (e.g. query for product id and English(US)<br>
description of first image)</li>
<li>Show the result partial projection from original</li>
<li>Clearly labelled as partial</li>
</ul>
</li>
</ul>
</li>
<li><strong>Placement:</strong> Insert after paragraph discussing partial reconstruction</li>
</ul>
</li>
</ul>
<h1 id="data-model" tabindex="-1">Data Model <a class="direct-link" href="#data-model" aria-hidden="true">#</a></h1>
<p>For a moment consider a nested data model with the following restrictions:</p>
<ol>
<li>All fields are mandatory. There are never any null values.</li>
<li>This model disallows list or array types, permitting only struct types and<br>
scalar types (includes integers, floating-point, boolean, characters and<br>
strings).</li>
</ol>
<p>In such a model, the structure of any data instance perfectly mirrors its<br>
schema. Consequently, the schema alone is sufficient to reconstruct the<br>
original nested data structure from its flattened representation.</p>
<ul>
<li>[ ] <strong>TODO:</strong> Diagram value mirrors schema structure perfectly</li>
</ul>
<p>Here we do not have to track the presence of a field because it can never be<br>
null. In this model, since all fields are mandatory and the model disallows<br>
lists, the cardinality of every field is therefore always one. Each field can be<br>
either a scalar or a struct value, never a collection. We do not have to<br>
determine if a list is empty.</p>
<p>If both restrictions are removed then different concrete values of the same<br>
nested schema can have many possible structures. In these cases, one cannot<br>
reverse the flattened values using the schema alone.</p>
<ul>
<li>[ ] <strong>TODO:</strong> Diagram concrete values of schema with optional fields</li>
<li>[ ] <strong>TODO:</strong> Diagram concrete value of schema with list field</li>
</ul>
<p>This simplified model restricts our ability to express most real-world<br>
nested datasets because it lacks optional fields and disallows lists. But it<br>
helps us narrow down the sources of structural variations.</p>
<ol>
<li>Is an optional field present or not?</li>
<li>Is a list empty or not?</li>
</ol>
<p>Consider a data model with these restrictions removed. It allows both<br>
optional fields and lists - the very features that introduce structural<br>
variations. Reconstructing any flattened nested data structure with a<br>
well-defined schema back to its original form is indeed possible, but this<br>
capability depends entirely on encoding these two structural properties<br>
(optional field presence and list status) as metadata.</p>
<h1 id="flattening" tabindex="-1">Flattening <a class="direct-link" href="#flattening" aria-hidden="true">#</a></h1>
<p>To flatten a nested data structure, we first enumerate its potential column<br>
attributes. This involves traversing the schema in depth-first order. Each<br>
column attribute corresponds to a unique path of fields from the document's<br>
root up to a leaf node. The field definition at this leaf node determines<br>
the optionality and data type for that column attribute.</p>
<ul>
<li>[ ] <strong>TODO:</strong> Diagram enumerate paths in a schema</li>
</ul>
<p>Next, we traverse an actual data instance of the nested structure, again in<br>
depth-first order. As we reach the leaf nodes in the data, we extract the<br>
scalar values and append them to the lists associated with their<br>
corresponding column attributes (as identified from the schema).</p>
<ul>
<li>[ ] <strong>TODO:</strong> Diagram flattening nested value to column values</li>
</ul>
<h1 id="metadata:-definition-level" tabindex="-1">Metadata: Definition Level <a class="direct-link" href="#metadata:-definition-level" aria-hidden="true">#</a></h1>
<p>A path may terminate early before it reaches the leaf node. This happens<br>
when an optional field is not present in the value tree. There is also a<br>
possibility that a path defined in the schema is not present in the value<br>
tree. Here the first field in the path is an optional field and is not<br>
present in the value. This will go undetected without the schema.</p>
<ul>
<li>[ ] <strong>TODO:</strong> Diagram various legal constructions of terminating paths</li>
</ul>
<p>A path may also contain list fields which maybe empty in the value. So we<br>
need to know in the case of a list field whether it is empty or contains at<br>
least one element.</p>
<p>We can track both cases by counting the optional fields which are present<br>
and list fields which are not empty. If an optional field is present the<br>
count is incremented by one. If a list field contains at least one element<br>
the count is incremented by one. Note that the count is only incremented by<br>
one for the list field and does not depend on the number of elements in the<br>
list.</p>
<p>The terminology used by Dremel for this count metadata field is <strong>definition<br>
level</strong>. If a path contains N optional fields and list fields, then its<br>
definition level will be in the range (inclusive) [0, N]. The upper bound<br>
can be derived from the schema.</p>
<p>The definition level of a non-NULL value will always be N. For null values<br>
the definition level tell us the exact point at which the path terminates.<br>
This allows us to reconstruct partially terminated paths. If the definition<br>
level is 0, we know that path is entirely missing from the value.</p>
<h1 id="metadata:-repetition-level" tabindex="-1">Metadata: Repetition Level <a class="direct-link" href="#metadata:-repetition-level" aria-hidden="true">#</a></h1>
<p>A list field is variable length and maps to multiple values in a flattened<br>
representation. Here it should be possible to determine list boundaries so<br>
that the flattened values can be reverse mapped back to the correct list field.</p>
<p>A schema path may define multiple list fields (nested lists). This poses<br>
a serious challenge in also having to identify at which level of nesting a<br>
flattened value belongs.</p>
<p>Here we need to consider only the non-empty list fields because an empty<br>
list field is already handled by the definition level.</p>
<p>Dremel uses a clever trick to encode both the list boundary and nesting<br>
level of a flattened list element into a single metadata value known as<br>
repetition level.</p>
<p>There are similarities to how definition level tracks the presence of<br>
optional/list fields along a path. The maximum possible repetition level for<br>
any value along a given schema path (let's call it R) is equal to the number<br>
of list fields defined in that schema path. The actual repetition level (r)<br>
assigned to a flattened value will then fall within the range (inclusive) [0,<br>
R]. If R = 2, then a flattened value can have a repetition level of 0, 1 or 2.</p>
<p>From interpreting the repetition level of a flattened value we can identify<br>
the record it belongs to and the nesting level within the record if the<br>
schema path defines nested lists.</p>
<p>The rules for interpreting repetition levels are:<br>
If r = 0: The value marks the beginning a new record. It is the first<br>
occurrence of this specific field path within that new record.<br>
If r &lt; R (max repetition level for a path): This is the first element of a<br>
new instance of a nested list. The value of 'r' tells us which list in the<br>
path (from root to leaf) this new instance belongs to.<br>
If r = R: This value is a subsequent item belonging to the same instance<br>
of most recent list that was previously started.</p>
<h1 id="metadata:-required-fields-only-path" tabindex="-1">Metadata: required fields only path <a class="direct-link" href="#metadata:-required-fields-only-path" aria-hidden="true">#</a></h1>
<p>Consider a schema path that contains no optional fields and no list fields.<br>
For any value present along such a path the definition level will always be<br>
zero as there are no optional or list fields. The repetition level will<br>
always be zero as there are no list fields.</p>
<p>In this specific scenario, which mirrors our simplified data model, the<br>
schema alone is indeed sufficient to reconstruct the data, as no structural<br>
variations due to optionality or repetition exist.</p>
<h1 id="putting-it-all-together" tabindex="-1">Putting it all together <a class="direct-link" href="#putting-it-all-together" aria-hidden="true">#</a></h1>
<p>Let us now see how this works in practice.</p>
<h2 id="schema" tabindex="-1">Schema <a class="direct-link" href="#schema" aria-hidden="true">#</a></h2>
<pre><code>ProductImages (doc)
|- product_id (u64)
|- images
|  |- primary_id (u64)
|  |- secondary_image_ids (list u64)
|- alt_text
   |- localizations (list)
      |- locale (string)
      |- description (optional string)
      |- keywords (list string)
</code></pre>
<p>This schema represents a nested data structure which contains references to<br>
the display images belonging to a product. It also provides zero or more<br>
localized alt text entries for internationalization (i18n). Each entry has a<br>
locale, description (the alt text itself), and keywords (for seo).</p>
<p>The individual attributes present in this schema are:</p>
<table>
<thead>
<tr>
<th>No.</th>
<th>Schema Path</th>
<th>Data Type</th>
<th>Optional</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>product_id</td>
<td>u64</td>
<td>N</td>
</tr>
<tr>
<td>2</td>
<td>images.primary_id</td>
<td>u64</td>
<td>N</td>
</tr>
<tr>
<td>3</td>
<td>images.secondary_image_ids</td>
<td>u64</td>
<td>N</td>
</tr>
<tr>
<td>4</td>
<td>alt_text.localizations.locale</td>
<td>string</td>
<td>N</td>
</tr>
<tr>
<td>5</td>
<td>alt_text.localizations.description</td>
<td>string</td>
<td>Y</td>
</tr>
<tr>
<td>6</td>
<td>alt_text.localizations.keywords</td>
<td>string</td>
<td>N</td>
</tr>
</tbody>
</table>
<p>Each path in our schema has a maximum possible definition level (D) and<br>
repetition level (R). The maximum D is calculated by counting how many<br>
fields along the path are either optional or list types. The maximum R is<br>
the count of just the list type fields along the path. For our ProductImages<br>
schema, these maximums are:</p>
<table>
<thead>
<tr>
<th>No.</th>
<th>Schema Path</th>
<th>D</th>
<th>R</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>product_id</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>images.primary_id</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>images.secondary_image_ids</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>alt_text.localizations.locale</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>alt_text.localizations.description</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>alt_text.localizations.keywords</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>D - Definition Level<br>
R - Repetition Level</p>
<h3 id="document-1-(d1)" tabindex="-1">document 1 (D1) <a class="direct-link" href="#document-1-(d1)" aria-hidden="true">#</a></h3>
<p>Multiple holes are present in this document. the secondary images list is<br>
empty. the single localization which is present does not have any keywords<br>
defined yet.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">product_id</span><span class="token punctuation">:</span> <span class="token number">101</span><br><span class="token key atrule">images</span><span class="token punctuation">:</span><br>  <span class="token key atrule">primary_id</span><span class="token punctuation">:</span> <span class="token number">2001</span><br>  <span class="token key atrule">secondary_image_ids</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span><br><span class="token key atrule">alt_text</span><span class="token punctuation">:</span><br>  <span class="token key atrule">localizations</span><span class="token punctuation">:</span><br>    <span class="token punctuation">-</span> <span class="token key atrule">locale</span><span class="token punctuation">:</span> <span class="token string">"en-us"</span><br>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"blue casual t-shirt."</span><br>      <span class="token key atrule">keywords</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span></code></pre>
<h3 id="document-2-(d2)" tabindex="-1">document 2 (D2) <a class="direct-link" href="#document-2-(d2)" aria-hidden="true">#</a></h3>
<p>This document contains only the product id and primary image id. the<br>
remaining properties are either missing or empty.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">product_id</span><span class="token punctuation">:</span> <span class="token number">102</span><br><span class="token key atrule">images</span><span class="token punctuation">:</span><br>  <span class="token key atrule">primary_id</span><span class="token punctuation">:</span> <span class="token number">3010</span><br>  <span class="token key atrule">secondary_image_ids</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span><br><span class="token key atrule">alt_text</span><span class="token punctuation">:</span><br>  <span class="token key atrule">localizations</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span></code></pre>
<h3 id="document-3-(d3)" tabindex="-1">document 3 (D3) <a class="direct-link" href="#document-3-(d3)" aria-hidden="true">#</a></h3>
<p>This is a fairly complete document with multiple secondary image ids and<br>
multiple localizations with varied content.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">product_id</span><span class="token punctuation">:</span> <span class="token number">103</span><br><span class="token key atrule">images</span><span class="token punctuation">:</span><br>  <span class="token key atrule">primary_id</span><span class="token punctuation">:</span> <span class="token number">4400</span><br>  <span class="token key atrule">secondary_image_ids</span><span class="token punctuation">:</span><br>    <span class="token punctuation">-</span> <span class="token number">4401</span><br>    <span class="token punctuation">-</span> <span class="token number">4402</span><br>    <span class="token punctuation">-</span> <span class="token number">4403</span><br><span class="token key atrule">alt_text</span><span class="token punctuation">:</span><br>  <span class="token key atrule">localizations</span><span class="token punctuation">:</span><br>    <span class="token punctuation">-</span> <span class="token key atrule">locale</span><span class="token punctuation">:</span> <span class="token string">"en-us"</span><br>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"red running shoe, side view."</span><br>      <span class="token key atrule">keywords</span><span class="token punctuation">:</span><br>        <span class="token punctuation">-</span> <span class="token string">"red shoe"</span><br>        <span class="token punctuation">-</span> <span class="token string">"running"</span><br>        <span class="token punctuation">-</span> <span class="token string">"sport"</span><br>    <span class="token punctuation">-</span> <span class="token key atrule">locale</span><span class="token punctuation">:</span> <span class="token string">"en-au"</span><br>      <span class="token comment"># placeholder locale does not yet have a description</span><br>      <span class="token key atrule">keywords</span><span class="token punctuation">:</span><br>        <span class="token punctuation">-</span> <span class="token string">"red runner"</span><br>        <span class="token punctuation">-</span> <span class="token string">"jogging"</span><br>    <span class="token punctuation">-</span> <span class="token key atrule">locale</span><span class="token punctuation">:</span> <span class="token string">"en-gb"</span><br>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"red trainer, profile."</span><br>      <span class="token key atrule">keywords</span><span class="token punctuation">:</span><br>        <span class="token punctuation">-</span> <span class="token string">"trainer"</span><br>        <span class="token punctuation">-</span> <span class="token string">"athletics"</span></code></pre>
<p>After flattening the documents, the values in each path are stored contiguously.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">product_id</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">102</span><span class="token punctuation">,</span> <span class="token number">103</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">]</span><br><br><span class="token key atrule">images.primary_id</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">2001</span><span class="token punctuation">,</span> <span class="token number">3010</span><span class="token punctuation">,</span> <span class="token number">4400</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">]</span></code></pre>
<p>The paths product_id and images.primary_id contain only mandatory fields. So<br>
the derived definition and repetition level values is going to be zero for<br>
all values. So it is equivalent to the following storage representation.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">product_id</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">102</span><span class="token punctuation">,</span> <span class="token number">103</span> <span class="token punctuation">]</span><br><br><span class="token key atrule">images.primary_id</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">2001</span><span class="token punctuation">,</span> <span class="token number">3010</span><span class="token punctuation">,</span> <span class="token number">4400</span> <span class="token punctuation">]</span></code></pre>
<h2 id="path:-images.secondary_image_ids" tabindex="-1">Path: images.secondary_image_ids <a class="direct-link" href="#path:-images.secondary_image_ids" aria-hidden="true">#</a></h2>
<p>Step 1: Flatten D1</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">images.secondary_image_ids</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token null important">NULL</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span> <span class="token punctuation">]</span></code></pre>
<p>The definition level is zero because secondary_image_ids list is empty. The<br>
repetition level is zero here for the same reason. The repetition level for<br>
the path images.secondary_image_ids is in the range (inclusive) [0, 1]. Here<br>
the interpretation of zero is not that this is the first element in the list,<br>
which is not possible as the list is empty. But we have to read it together<br>
with the NULL value and the definition level value which happens to be zero<br>
and signals that the list is empty.</p>
<p>Step 2: Flatten D2</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">images.secondary_image_ids</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token null important">NULL</span><span class="token punctuation">,</span> <span class="token null important">NULL</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">]</span></code></pre>
<p>The same reasoning as above applies here.</p>
<p>Step 3: Flatten D3</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">images.secondary_image_ids</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token null important">NULL</span><span class="token punctuation">,</span> <span class="token null important">NULL</span><span class="token punctuation">,</span> <span class="token number">4401</span><span class="token punctuation">,</span> <span class="token number">4402</span><span class="token punctuation">,</span> <span class="token number">4403</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">]</span></code></pre>
<p>As the list is not empty, the definition level for all values in this list<br>
is 1. The repetition level for the first element 4401 is zero, and for<br>
subsequent elements the repetition level is one. This marks 4401 as the<br>
beginning of a new list instance in a new document.</p>
<h2 id="path-4:-alt_text.localizations.locale" tabindex="-1">Path 4: alt_text.localizations.locale <a class="direct-link" href="#path-4:-alt_text.localizations.locale" aria-hidden="true">#</a></h2>
<p>The struct alt_text is required/mandatory and locale is a required/mandatory<br>
string. The localizations is a list. So this has a maximum definition level<br>
of 1 and maximum repetition levels is also 1.</p>
<p>The inner data type of localizations is a struct with three properties:</p>
<ul>
<li>locale: a required/mandatory string</li>
<li>description: an optional string</li>
<li>keywords: a list of strings</li>
</ul>
<p>Step 1: Flatten D1</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">alt_text.localizations.locale</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"en-us"</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">1</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span> <span class="token punctuation">]</span></code></pre>
<p>In D1 a single locale is defined. So the derived definition level is 1<br>
because the localizations list is present. The repetition level is 0 which<br>
indicates that this is the first occurrence of the locale struct property in<br>
a new instance of the localizations list in a new document.</p>
<p>Step 2: Flatten D2</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">alt_text.localizations.locale</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"en-us"</span><span class="token punctuation">,</span> <span class="token null important">NULL</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">]</span></code></pre>
<p>In D2 the localizations list is empty. So the definition level becomes 0 and<br>
NULL value is inserted. The repetition level is zero, but has to interpreted<br>
together with the NULL value and definition level which shows that the<br>
localizations list is empty in this document.</p>
<p>Step 3: Flatten D3</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">alt_text.localizations.locale</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"en-us"</span><span class="token punctuation">,</span> <span class="token null important">NULL</span><span class="token punctuation">,</span> <span class="token string">"en-us"</span><span class="token punctuation">,</span> <span class="token string">"en-au"</span><span class="token punctuation">,</span> <span class="token string">"en-gb"</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">]</span></code></pre>
<p>There are three locale values in D3. They are added to values. The<br>
definition level is 1 because the localizations is not empty. The<br>
repetition level is 0 for &quot;en-us&quot; which signals that this is the beginning<br>
of a new localizations list instance in a new document and this is the<br>
first element. The subsequent elements in the list therefore have the<br>
repetition level of 1.</p>
<h2 id="path-5:-alt_text.localizations.description" tabindex="-1">Path 5: alt_text.localizations.description <a class="direct-link" href="#path-5:-alt_text.localizations.description" aria-hidden="true">#</a></h2>
<p>In this path localizations is a list and description is an optional string.<br>
So the maximum definition level is 2. The maximum value for repetition level<br>
is 1 as there is only a single list in this path.</p>
<p>Step 1: Flatten D1</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">alt_text.localizations.description</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"blue casual t-shirt"</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">2</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span> <span class="token punctuation">]</span></code></pre>
<p>The optional description is present in D1. So the definition level is 2, and<br>
the repetition level is 0. This is the first description in a new instance<br>
of localizations, at the start of the document.</p>
<p>Step 2: Flatten D2</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">alt_text.localizations.description</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"blue casual t-shirt"</span><span class="token punctuation">,</span> <span class="token null important">NULL</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">]</span></code></pre>
<p>In D2, the localizations list is empty. A NULL value is inserted for<br>
description. The definition level is 1 indicating that the path is defined<br>
up to the localizations list field, but the list is empty so no actual<br>
description value exists within a list item. The repetition level is 0, as<br>
the entry corresponds to a new record (D2).</p>
<p>Step 3: Flatten D3</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">alt_text.localizations.description</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span><br>    <span class="token punctuation">-</span> <span class="token string">"blue casual t-shirt"</span>         <span class="token comment"># D1</span><br>    <span class="token punctuation">-</span> <span class="token null important">NULL</span>                          <span class="token comment"># D2</span><br>    <span class="token punctuation">-</span> <span class="token string">"red running shoe, side view"</span> <span class="token comment"># D3</span><br>    <span class="token punctuation">-</span> <span class="token null important">NULL</span>                          <span class="token comment"># D3</span><br>    <span class="token punctuation">-</span> <span class="token string">"red trainer, profile"</span>        <span class="token comment"># D3</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">]</span></code></pre>
<p>The second description is not present, so a NULL value is inserted in its<br>
place and its definition level is 1. The first description and third<br>
description are present, so they have a definition level of 2. The<br>
repetition level of the first description is 0 to indicate that this is a<br>
new instance of a localizations list, and this is the first description<br>
property in the first struct element. The subsequent descriptions have a<br>
repetition level of 1 to indicate that they are elements belonging to this same<br>
list.</p>
<h2 id="path-6:-alt_text.localizations.keywords" tabindex="-1">Path 6: alt_text.localizations.keywords <a class="direct-link" href="#path-6:-alt_text.localizations.keywords" aria-hidden="true">#</a></h2>
<p>This is the first time we encounter a nested list. Both localizations and<br>
keywords are list fields. The maximum definition level is 2 and the maximum<br>
repetition level is also 2 for this path.</p>
<p>Step 1: Flatten D1</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">alt_text</span><span class="token punctuation">:</span><br>  <span class="token key atrule">localizations</span><span class="token punctuation">:</span><br>    <span class="token punctuation">-</span> <span class="token key atrule">locale</span><span class="token punctuation">:</span> <span class="token string">"en-us"</span><br>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"blue casual t-shirt."</span><br>      <span class="token key atrule">keywords</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span></code></pre>
<p>In D1, keywords list is present, but it is empty.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">alt_text.localizations.keywords</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token null important">NULL</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">1</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span> <span class="token punctuation">]</span></code></pre>
<p>We insert a NULL value because keywords list is empty. The definition level<br>
is 1 as localizations list is present and not empty, but the keywords list<br>
is empty. The repetition level is zero because this is the start of a new<br>
record (D1).</p>
<p>Step 2: Flatten D2</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">alt_text</span><span class="token punctuation">:</span><br>  <span class="token key atrule">localizations</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span></code></pre>
<p>In D2, the localizations list is empty.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">alt_text.localizations.keywords</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token null important">NULL</span><span class="token punctuation">,</span> <span class="token null important">NULL</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">]</span></code></pre>
<p>The definition level in this case is 0 because the localizations list is<br>
empty. The repetition level is 0 because this is the start of a new record (D2).</p>
<p>Step 3: Flatten D3</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">alt_text</span><span class="token punctuation">:</span><br>  <span class="token key atrule">localizations</span><span class="token punctuation">:</span><br>    <span class="token punctuation">-</span> <span class="token key atrule">locale</span><span class="token punctuation">:</span> <span class="token string">"en-us"</span><br>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"red running shoe, side view."</span><br>      <span class="token key atrule">keywords</span><span class="token punctuation">:</span><br>        <span class="token punctuation">-</span> <span class="token string">"red shoe"</span><br>        <span class="token punctuation">-</span> <span class="token string">"running"</span><br>        <span class="token punctuation">-</span> <span class="token string">"sport"</span><br>    <span class="token punctuation">-</span> <span class="token key atrule">locale</span><span class="token punctuation">:</span> <span class="token string">"en-au"</span><br>      <span class="token comment"># placeholder locale does not yet have a description</span><br>      <span class="token key atrule">keywords</span><span class="token punctuation">:</span><br>        <span class="token punctuation">-</span> <span class="token string">"red runner"</span><br>        <span class="token punctuation">-</span> <span class="token string">"jogging"</span><br>    <span class="token punctuation">-</span> <span class="token key atrule">locale</span><span class="token punctuation">:</span> <span class="token string">"en-gb"</span><br>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"red trainer, profile."</span><br>      <span class="token key atrule">keywords</span><span class="token punctuation">:</span><br>        <span class="token punctuation">-</span> <span class="token string">"trainer"</span><br>        <span class="token punctuation">-</span> <span class="token string">"athletics"</span></code></pre>
<p>The localizations list contains 3 items. So let us break this up by item so<br>
we can clearly see how repetition levels varies across keywords for each item.</p>
<p>After processing the first item in localizations:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">alt_text.localizations.keywords</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"red shoe"</span><span class="token punctuation">,</span> <span class="token string">"running"</span><span class="token punctuation">,</span> <span class="token string">"sport"</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">]</span></code></pre>
<p>The localizations list is present and the keywords list is present, and both<br>
are not empty. So the definition level is 2. The first item in the list has<br>
a repetition level of 0 because this is the beginning of a new record (D3).<br>
The other items have a repetition level of 2 to indicate that this is a<br>
continuation of the current keywords list.</p>
<p>Now the second item,</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">alt_text.localizations.keywords</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"red runner"</span><span class="token punctuation">,</span> <span class="token string">"jogging"</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">]</span></code></pre>
<p>The definition level is 2 as both lists in the path are present. Note that<br>
the repetition level for &quot;red runner&quot; is not zero. This is significant! This<br>
keywords field is part of the second struct item in localizations. And<br>
localizations has a repetition level in the range (inclusive) [0, 1]. The 0<br>
repetition level marks the beginning of a new record, but here this is the<br>
second item in the localizations list. The computed repetition level is<br>
therefore 1 for all remaining structs in this list. Now when we reach the<br>
keywords list, this is a new list instance and &quot;red runner&quot; is the first<br>
element in the list. So the repetition level for &quot;red runner&quot; is 1. The<br>
remaining items in the list have a repetition level of 2 to indicate that it<br>
is a continuation of the newly opened list.</p>
<p>And the final item in localizations,</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">alt_text.localizations.keywords</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"trainer"</span><span class="token punctuation">,</span> <span class="token string">"athletics"</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">]</span></code></pre>
<p>The repetition level of &quot;trainer&quot; is 1 because it is child property of the<br>
third struct item in localizations list. The repetition level for the third<br>
item can only be 1. Also, &quot;trainer&quot; is the first item in the new instance of<br>
keywords list so we give it a repetition level of 1 to identify it as the<br>
first element in a new keywords list. The remaining items in keywords get a<br>
repetition level of 2.</p>
<p>The final aggregation of keywords after processing D1, D2 and all three<br>
localization items from D3:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">alt_text.localizations.keywords</span><span class="token punctuation">:</span><br>  <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><br>    <span class="token null important">NULL</span><span class="token punctuation">,</span>                           <span class="token comment"># D1: keywords list is empty</span><br>    NULL<span class="token punctuation">,</span>                           <span class="token comment"># D2: localizations list is empty</span><br>    "red shoe"<span class="token punctuation">,</span> <span class="token string">"running"</span><span class="token punctuation">,</span> <span class="token string">"sport"</span><span class="token punctuation">,</span> <span class="token comment"># D3: 1st localization ("en-us")</span><br>    "red runner"<span class="token punctuation">,</span> <span class="token string">"jogging"</span><span class="token punctuation">,</span>        <span class="token comment"># D3: 2nd localization ("en-au")</span><br>    "trainer"<span class="token punctuation">,</span> <span class="token string">"athletics"</span>          <span class="token comment"># D3: 3rd localization ("en-gb")</span><br>  <span class="token punctuation">]</span><br>  <span class="token key atrule">def</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><br>    <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token comment"># D1: (localizations present, keywords empty)</span><br>    0<span class="token punctuation">,</span>        <span class="token comment"># D2: (localizations empty)</span><br>    2<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token comment"># D3: (both list present and non-empty)</span><br>    2<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span><br>    <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><br>  <span class="token punctuation">]</span><br>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><br>    <span class="token number">0</span><span class="token punctuation">,</span>        <span class="token comment"># D1: new record</span><br>    0<span class="token punctuation">,</span>        <span class="token comment"># D2: new record</span><br>    0<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token comment"># D3: 1st localization: r=0 for first keyword, r=2 for remaining</span><br>    1<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span>     <span class="token comment"># D3: 2nd localization: r=1 for first keyword, r=2 for remaining</span><br>    1<span class="token punctuation">,</span> <span class="token number">2</span>      <span class="token comment"># D3: 3rd localization: r=1 for first keyword, r=2 for remaining</span><br>  <span class="token punctuation">]</span></code></pre>
<hr>
<p>In columnar storage values of a single column attribute are stored<br>
contiguously. In analytics databases the query optimizer can apply<br>
projection pushdown directly to the data source. This means only those columns<br>
which are specified in the query are read from storage. Analytical queries are<br>
often aggregations over the entire data source. So this can reduce the I/O<br>
required and make the queries run faster.</p>
<p>It is easy to map flat relational data to columns. Given a projection of<br>
columns the original record can be reassembled by index or offset. A record<br>
has the same index or offset across all columns. This is not the case with<br>
nested data structures.</p>
<p>If nested data structures can be shredded into columns, then it is possible<br>
to use a SQL or DataFrame interface to query nested data. All the built-in<br>
optimizations which are available for relational data also then becomes<br>
available to nested data structures. The ability to interactively query millions<br>
or billions of nested data becomes possible in a single node using a vectorized<br>
query execution engines like DuckDB, ClickHouse or Apache DataFusion.</p>
<pre><code># First record
ProductId: 123
ImageGallery:
  PrimaryImageId: 555
  AdditionalImageId:
    - 556
    - 557

# Second record
ProductId: 678
ImageGallery:
  PrimaryImageId: 987
  AdditionalImageId:
    - 988
    - 989
    - 990
</code></pre>
<p>Nested data structures are tree shaped. The atomic or primitive value is<br>
found at the leaf of the tree. And columns in the nested data structure is<br>
the path from root to leaf. The columns with their data type are:</p>
<ol>
<li>ProductId - Integer</li>
<li>ImageGallery.PrimaryImageId - Integer</li>
<li>ImageGallery.AdditionalImageId - Array[Integer]</li>
</ol>
<p>The two records above after being shredded into column values will look like<br>
this:</p>
<pre><code>ProductId                       : [123, 678]
ImageGallery.PrimaryImageId     : [555, 987]
ImageGallery.AdditionalImageId  : [556, 557, 988, 989, 990]
</code></pre>
<p>In the absence of other metadata it is now impossible for us to reassemble<br>
the original records. The structural information is lost with this encoding.<br>
We are unable to identify where a record begins or ends when the nested data<br>
structure contains repeated (array) values. In this representation it is not<br>
possible anymore to know which values in <code>ImageGallery.AdditionalImageId</code><br>
belongs to which records.</p>
<pre><code># First record
ProductId: 123
ImageGallery:
  PrimaryImageId: 555
  AdditionalImageId:
    - 556
    - 557
AltText:
  - Language:
      - Locale: en-US
        Description: Athletic running shoes
        Keyword:
          - shoes
          - running
          - athletic

# Second record
ProductId: 678
ImageGallery:
  PrimaryImageId: 987
  AdditionalImageId:
    - 988
    - 989
    - 990
</code></pre>
<p>Real world nested data structures are also sparse. In this example the<br>
first nested data contains descriptive text columns, but the second record<br>
does not. For partially or completely missing paths in a nested data<br>
structure NULL values are inserted. The more sparse the data because of<br>
missing column values, the more NULL values there will be.</p>
<pre><code>ProductId                       : [123, 678]
ImageGallery.PrimaryImageId     : [555, 987]
ImageGallery.AdditionalImageId  : [556, 557, 988, 989, 990]

# Columns present only in the first record
AltText.Language.Locale         : [&quot;en-US&quot;, NULL]
AltText.Language.Description    : [&quot;Athletic running shoes&quot;, NULL]
AltText.Language.Keyword        : [&quot;shoes&quot;, &quot;running&quot;, &quot;athletic&quot;, NULL]
</code></pre>
<p>The Dremel (Google BigQuery) paper (VLDB 2010) introduced a new<br>
representation for nested data in columnar storage which also stored the<br>
structural hierarchy of the nested data side by side with the column values.<br>
This metadata made it possible to reassemble the original nested data<br>
structure back from columnar format.</p>
<p>The ability to represent nested data directly in a columnar format meant<br>
increased developer productivity. There is no need to normalize the nested<br>
data by extracting entities and joining multiple relations using foreign<br>
keys in some star or snowflake schema for data analysis. Developers could<br>
use the SQL query execution for interactive analysis of very large nested<br>
datasets.</p>
<p>Later when Parquet was created it added ground up support nested data<br>
structures in its file format using the techniques and principles described<br>
in the Dremel paper.</p>
<p>For the <code>ImageGallery.AdditionalImageId</code> it was impossible to reassemble the<br>
original two records by looking at only the stored column values. In Dremel<br>
they introduced metadata which encodes the structure of the values in the<br>
nested data. They are definition level and repetition level.</p>
<p>In the below example by reading <code>d</code> (definition level) and <code>r</code> (repetition<br>
level) in tandem with the column values the original nested values can be<br>
reassembled.</p>
<pre><code># ImageGallery.AdditionalImageId Column

d       : [1, 1, 1, 1, 1]             # definition level
r       : [0, 1, 0, 1, 1]             # repetition level
values  : [556, 557, 988, 989, 990]
</code></pre>
<p>To compute the definition level of <code>ImageGallery.AdditionalImageId</code> we need<br>
to count all the optional and repeated fields in it. To compute the<br>
repetition level the index of the value must be known. If there are multiple<br>
repeated fields in column path, then the computed repetition level of the<br>
nearest repeated ancestor.</p>
<p>The schema of the nested data is required for us to know if a field is<br>
defined as required, optional or repeated. So let us inspect the schema for<br>
<code>ProductImages</code> document before formalizing the computation of definition<br>
and repetition levels from the nested data.</p>
<p>The schema for <code>ProductImages</code> is given below. From the schema we can see that<br>
this is a nested document which contains the display images for a product and<br>
language translations of the image descriptions.</p>
<p>The data model is,</p>
<ul>
<li>A field is either a struct type or a primitive type like an integer,<br>
string, float, boolean etc.</li>
<li>A field with no explicit multiplicity labels is a required field. A<br>
required field will always be present in the nested data.</li>
<li>An optional field is explicitly marked in the schema. In nested data this<br>
field maybe present or absent.</li>
<li>A repeated field is represented as an array of values. The type of<br>
repeated field can be either a struct type or a primitive type.</li>
<li>The ordering of repeated values is significant.</li>
<li>The leaf node is always a primitive type, or a repeated field of a<br>
primitive type.</li>
<li>A column name is represented using dot notation by joining the field names<br>
from root to leaf. Eg. <code>AltText.Language.Keyword</code></li>
<li></li>
</ul>
<pre><code>ProductImages                     # Document Name
├─ ProductId [int64]
├─ ImageGallery
│  ├─ PrimaryImageId [int64]
│  └─ AdditionalImageId [int64]*  # repeated
└─ AltText?                       # optional
   └─ Language*                   # repeated
      ├─ Locale [string]
      ├─ Description [string]?    # optional
      └─ Keyword [string]*        # repeated

* = repeated
? = optional
</code></pre>
<p>A definition level for a column value is computed by counting the occurrence<br>
of optional and repeated fields which are present in the value. If an optional<br>
field is absent then we do not increment the definition level. If a repeated<br>
field is empty or missing we do not increment the definition level. So the<br>
definition level can tell us where the path in a tree terminated for any<br>
given column value.</p>
<p>But this is not enough for us to reassemble repeated values. The repetition<br>
level is used to identify the beginning of an array from the rest of the<br>
array values. For computing repetition levels, only repeated fields in a<br>
path are counted.</p>
<p>In <code>ImageGallery.AdditionalImageId</code>,</p>
<ul>
<li><code>ImageGallery</code> is a required field</li>
<li><code>AdditionalImageId</code> is a repeated field</li>
</ul>
<pre><code># ImageGallery.AdditionalImageId Column

definition_levels : [1, 1, 1, 1, 1]
repetition_levels : [0, 1, 0, 1, 1]
values            : [556, 557, 988, 989, 990]
</code></pre>
<p>From the definition levels we can see that for all values the path is<br>
<code>ImageGallery.AdditionalImageId</code> because the definition level is 1 which<br>
means the repeated field <code>AdditionalImageId</code> in the path is always present.</p>
<p>There is only a single repeated field, so the repetition levels can be<br>
either zero or one. To identify the start of the array, the first element in<br>
this example will have a repetition level of zero. The remaining values in<br>
the array will have the repetition level of one. So <code>556</code> has repetition level<br>
of zero, and <code>557</code> has a repetition level of one.</p>
<p>For the next value <code>988</code> we can infer that it belongs to the second record<br>
because it has a repetition level of zero. This means it has to be the first<br>
value in the array. And the remaining values in the second record <code>989</code>, <code>989</code><br>
because they have a repetition level of 1.</p>
<p>In this example we were able to identify that the repeated values belonged<br>
to two separate nested values using the repetition levels.</p>
<p>Next let us look at a example which contains null values.</p>
<pre><code>ProductId: 123
ImageGallery:
  PrimaryImageId: 555
  AdditionalImageId:
    - 556
    - 557
AltText:
  - Language:
      - Locale: en-US
        Description: Athletic running shoes
        Keyword:
          - shoes
          - athletic
  - Language:
      - Locale: en-GB
        Description: Athletic trainers
        Keyword:
          - trainers
          - sport
  - Language:
      - Locale: fr-FR
  - Language:
      - Locale: de-DE
</code></pre>
<p>The column <code>AltText.Language.Description</code> contains a repeated field and<br>
exactly two optional fields. The definition level therefore can be between 0<br>
and 3.</p>
<ul>
<li>AltText: optional</li>
<li>Language: repeated</li>
<li>Description: optional</li>
</ul>
<p>After compiling the column values, there are two NULL values. This<br>
represents the missing <code>Description</code> in the 2nd and 3rd <code>Language</code><br>
repetition which corresponds to the <code>Locale</code>: <code>fr-FR</code> and <code>de-DE</code>.</p>
<pre><code># AltText.Language.Description Column

values: [&quot;Athletic running shoes&quot;, &quot;Athletic trainers&quot;, NULL, NULL]
</code></pre>
<p>Next let us compute the definition levels. The definition level for both the<br>
NULL values is two because the path terminates at <code>AltText.Language</code> as the<br>
<code>Description</code> field is missing in both cases.</p>
<pre><code># AltText.Language.Description Column

definition_levels : [3, 3, 2, 2]
values            : [&quot;Athletic running shoes&quot;, &quot;Athletic trainers&quot;, NULL, NULL]
</code></pre>
<p>Next let us compute the repetition levels. This column has a single repeated<br>
field which is <code>Language</code>. So repetition levels will be between 0 and 1 for<br>
all values.</p>
<p>Here the repetition level of zero clearly identifies the first element in<br>
the repeated field <code>Language</code>, from the rest.</p>
<pre><code># AltText.Language.Description Column

repetition_levels : [0, 1, 1, 1]
definition_levels : [3, 3, 2, 2]
values            : [&quot;Athletic running shoes&quot;, &quot;Athletic trainers&quot;, NULL, NULL]
</code></pre>
<p>Next let us look at an example where there is more than one repeated field<br>
in a column. The <code>AltText.Language.Keyword</code> column has two repeated fields<br>
and a single optional field.</p>
<p>Let us compile the values first. The final two NULL values represent the<br>
missing <code>Keyword</code> in the second and third repetition of <code>Language</code>.</p>
<pre><code># AltText.Language.Keywords

values: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;, NULL, NULL]
</code></pre>
<p>Next let us compute the definition levels. The NULL values have a definition<br>
level of two because <code>Keyword</code> field is missing.</p>
<pre><code># AltText.Language.Keyword

values: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;, NULL, NULL]
def   : [3, 3, 3, 3, 2, 2]
</code></pre>
<p>Next let us compute the repetition levels. This looks complicated, but you<br>
will soon see how this exactly reassembles the original nested data structure.</p>
<pre><code># AltText.Language.Keyword

values: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;, NULL, NULL]
def   : [3, 3, 3, 3, 2, 2]
rep   : [0, 2, 1, 2, 1, 1]
</code></pre>
<p>Let us look at the nested column in isolation and give it index numbers.</p>
<pre><code>AltText:
  - Language:         # Language[0]
        - Keyword:
          - shoes     # Language[0].Keyword[0]
          - athletic  # Language[0].Keyword[0]
  - Language:         # Language[1]
        - Keyword:
          - trainers  # Language[1].Keyword[0]
          - sport     # Language[1].Keyword[1]
  - Language:         # Language[2]
  - Language:         # Language[3]
</code></pre>
<p>There are two repeated fields <code>Alt.Language.Keyword</code> which are <code>Language</code><br>
and then <code>Keyword</code>. So values in this column may have repetition levels - 0,<br>
1 or 2.</p>
<p>The complete path for <code>shoes</code> is <code>Language[0].Keyword[0]</code>. This value is the<br>
first repeated value in the path of this nested data structure. The<br>
repetition level of <code>Language[0]</code> is zero. The repetition level of <code>Keyword [0]</code> is also zero. It inherits the repetition level of the nearest repeated<br>
ancestor.</p>
<p>The second value is <code>athletic</code> with path <code>Language[0].Keyword[1]</code>. The<br>
computed repetition level is two so that we can distinctly identify that<br>
this is not the first item in <code>Keyword</code>. Because this is not the first item<br>
we do not have to consider the repetition level of a repeated ancestor. Here<br>
<code>Keyword</code> field is the second repeated field of this column which is present<br>
and therefore the repetition level is two.</p>
<p>The third value is <code>trainers</code>. It has the path <code>Language[1].Keyword[0]</code>.<br>
Even though this is the first Keyword, it is the second repetition of<br>
Language. So the repetition level of <code>Language[1]</code> is one. And since it is<br>
the first keyword, we inherit that value. So the computed repetition level<br>
is one.</p>
<p>The fourth value is <code>sport</code> and the path is <code>Language[1].Keyword[1]</code>. The<br>
computed repetition level is two here. This is the second keyword, and so<br>
the repetition level is same as the number of repeated fields in this path<br>
which happens to be two.</p>
<p>The fifth and sixth values are both NULL. They have the paths <code>Language[2]</code><br>
and <code>Language[3]</code>. The <code>Keyword</code> field is empty or missing. So we compute<br>
the repetition level up to <code>Language</code> field. And the value is one.</p>
<pre><code># AltText.Language.Keyword

values: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;, NULL, NULL]
def   : [3, 3, 3, 3, 2, 2]
rep   : [0, 2, 1, 2, 1, 1]
</code></pre>
<p>Now that we know how definition and repetition levels are computed, it is<br>
possible to reassemble the nested data structure from the column values,<br>
definition and repetition levels.</p>
<p>From the column storage values we can also reassemble a partial projection of<br>
the nested data structure in its original form. For example if only the<br>
following columns are selected - [ProductId, AltText.Language.Locale] which<br>
is stored in columnar format as,</p>
<pre><code># ProductId Column
values            : [123, 456]
definition_level  : [0, 0]
repetition_level  : [0, 0]

# AltText.Language.Locale
values            : ['en-US', 'en-GB', 'fr-FR', 'de-DE', NULL]
definition_level  : [2, 2, 2, 2, 0]
repetition_level  : [0, 1, 1, 1, 0]
</code></pre>
<p>The reassembled nested data structure resembles the original but contains<br>
only the selected columns.</p>
<pre><code># Record 1
ProductId: 123
AltText:
  - Language:
      - Locale: en-US
  - Language:
      - Locale: en-GB
  - Language:
      - Locale: fr-FR
  - Language:
      - Locale: de-DE

# Record 2
ProductId: 678
</code></pre>
<p>This is just a physical representation. In physical storage the NULL values<br>
can be omitted. Because we know that for the column <code>AltText.Language. Keyword</code> has a max definition level of 3. It has an optional field <code>AltText</code><br>
and two repeated fields <code>Language</code> and <code>Keyword</code>. So when we see a<br>
definition level value lower than 3, we know that it stands for a NULL value.<br>
This way we can avoid storing the NULL values. This is a useful property for<br>
real world nested data structures which are sparse, and therefore has many<br>
NULL values need not be physically stored saving space.</p>
<pre><code># AltText.Language.Keyword

# Logical representation
# values: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;, NULL, NULL]

# Physical representation which does not store NULL values
values: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;]
def   : [3, 3, 3, 3, 2, 2]
rep   : [0, 2, 1, 2, 1, 1]
</code></pre>
<p>In this example <code>ProductId</code> is a required field so there is no need to store<br>
the definition levels. The definition level is always zero for all values.<br>
Similarly, a definition level of zero implies that the repetition level is<br>
also zero. So we do not also need to store repetition levels.</p>
<pre><code># ProductId Column
values            : [123, 456]
definition_level  : [0, 0]
repetition_level  : [0, 0]
</code></pre>
<p>So in this encoding in physical storage we only write the column values.</p>
<pre><code># ProductId Column
values            : [123, 456]
</code></pre>
<hr>
<p>Draft Notes:</p>
<ul>
<li>Improve definition level explanation: counting number of optional and<br>
repeated fields in the path from root to where the value is found, or<br>
where the path terminates for NULL values or paths which are entirely<br>
missing which can happen if the first field in a path is optional and<br>
therefore is a NULL value.</li>
<li>In <code>AltText.Language.Keyword</code> the computation of repetition levels needs<br>
improvement. For e.g. in the case of &quot;athletic&quot; the second repeated field<br>
<code>Keyword</code> is repeating, therefore the repetition level switches from zero<br>
to two.</li>
<li>The path with index <code>Language[0].Keyword[1]</code> for demonstrating the<br>
relationship with repetition levels can be compiled as a table or a nested<br>
list. The key is to explicitly outline the repetition level no matter<br>
which format is used for visualizing the relationship.</li>
<li>A definition level less than maximum value means a NULL value at that<br>
specific position in the schema. The count provides clues as to where the<br>
path terminated.</li>
<li>Add visual diagrams like in the Twitter blog post - Dremel made simple<br>
with Parquet.</li>
<li>Include an example of a flat schema with a required, optional and repeated<br>
field.</li>
<li>Include bit-level packing of definition, repetition levels.</li>
<li>The twitter blog post includes examples of how useful data structures like<br>
map (key, value) are implemented. It maybe useful to show the separation<br>
between logical and physical types. Map is a logical type which is<br>
rewritten to a struct physical type with a required key of type string,<br>
and an optional value of a primitive type or a record type.</li>
<li>The twitter blog post also includes a nested list example for<br>
demonstrating repetition levels. I need to reference it again to check how<br>
it is represented logically similar to the map type.</li>
<li>Include a couple of practical SQL query examples over the column<br>
shredded nested data structures using Apache DataFusion. The test data can<br>
be generated and written using python to Parquet format.</li>
<li>Parquet precomputed offset index which helps with deeply nested<br>
documents where otherwise we have to scan the definition, repetition<br>
levels from beginning to end to jump to a record. Include a concrete<br>
example.</li>
<li>Include record reassembly as a separate example instead of merging it with<br>
the explanation of definition, and repetition levels.</li>
<li>Schema merging in Parquet. Include an example.</li>
<li>In proto3 there is a significant change. Fields are optional by default<br>
and need not be marked as optional. They don't use the optional keyword<br>
anymore. The paper uses the proto2 syntax and semantics. The optional<br>
fields are explicitly marked. So proto3 removed required fields and uses<br>
default values for missing fields instead of explicitly tracking presence.<br>
This means it is not possible anymore to identify if a field which was<br>
explicitly set to default value vs one which was not set at all. But this<br>
change was included to make it possible to mark an optional field as<br>
required (dangerous) made it challenging for schema evolution. But proto3<br>
reintroduced the optional keyword again.</li>
<li>Include concrete SQL example for predicate pushdown.</li>
<li>Include Zero-Copy Optimization when reading from Parquet to Arrow.<br>
Remapping definition levels to validity bitmaps, and repetition levels to<br>
offset indexes. The last entry (n+1 for n items) indicates position after<br>
the last element. This also has to do with point access when you want to<br>
read all the values for record N, you can do offset[N-1] - offset[N] and<br>
directly read only those values from offset[N-1].</li>
<li>This is not a post about light-weight compression schemes, so I am not<br>
adding anything about dictionary encoding, run-length encoding etc.</li>
</ul>
<hr>
<p>Predicate Pushdown for Nested Fields - Concrete Example<br>
Consider a schema with nested e-commerce orders:<br>
Order<br>
├─ OrderId<br>
├─ Customer<br>
│ ├─ CustomerId<br>
│ ├─ Name<br>
│ └─ PremiumStatus<br>
└─ Items [array]<br>
├─ ProductId<br>
├─ Quantity<br>
└─ Price<br>
Let's say we want all orders where any item has a price over $100:</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><br><span class="token keyword">FROM</span> orders<br><span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> UNNEST<span class="token punctuation">(</span>items<span class="token punctuation">)</span> <span class="token keyword">WHERE</span> price <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span></code></pre>
<p>Traditional Approach:</p>
<p>Read all columns for all Order records<br>
Reconstruct the full nested structure<br>
Apply the filter to each record<br>
Return matching records</p>
<p>Predicate Pushdown with Nested Fields:</p>
<p>The query engine identifies that only the Items.Price column needs examining<br>
first<br>
It reads only the Items.Price column with its definition and repetition levels<br>
It creates a bitmap of which Orders have at least one item with price &gt; $100<br>
It then only reads the remaining columns for Orders that matched the filter</p>
<p>For a dataset with 1 million orders but only 5% having items over $100, this<br>
approach reads only 5% of the data for most columns.</p>
<hr>

<hr>
<ul><li>Previous: <a href="/posts/fourthpost/">This is my fourth post.</a></li>
</ul>

    </main>

    <footer></footer>

    <!-- Current page: /posts/dremel-column-striping/ -->
  </body>
</html>
