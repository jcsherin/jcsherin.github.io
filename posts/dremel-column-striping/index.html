<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nested Record Shredding</title>
    <meta name="description" content="Shredding nested data for columnar storage">
    <meta name="generator" content="Eleventy v1.0.1">

    <link rel="stylesheet" href="/css/index.css">
    <link rel="stylesheet" href="/css/prism-base16-monokai.dark.css">
    <link rel="stylesheet" href="/css/prism-diff.css">
    <link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="jcsherin">
    <link rel="alternate" href="/feed/feed.json" type="application/json" title="jcsherin">
  </head>
  <body>
    <header>
      <h1 class="home"><a href="/">jcsherin</a></h1>
      <ul class="nav">
        <li class="nav-item"><a href="/">Home</a></li>
        <li class="nav-item"><a href="/posts/">Archive</a></li>
        <li class="nav-item"><a href="/about/">About Me</a></li>
      </ul>
    </header>

    <main class="tmpl-post">
      <h1>Nested Record Shredding</h1>

<time datetime="2025-04-21">21 Apr 2025</time><a href="/tags/record-shredding/" class="post-tag">record shredding</a><a href="/tags/column-striping/" class="post-tag">column striping</a><a href="/tags/nested-data/" class="post-tag">nested data</a>

<p>In columnar storage values of a single column attribute are stored<br>
contiguously. In analytics databases the query optimizer can apply<br>
projection pushdown directly to the data source. This means only those columns<br>
which are specified in the query are read from storage. Analytical queries are<br>
often aggregations over the entire data source. So this can reduce the I/O<br>
required and make the queries run faster.</p>
<p>It is easy to map flat relational data to columns. Given a projection of<br>
columns the original record can be reassembled by index or offset. A record<br>
has the same index or offset across all columns. This is not the case with<br>
nested data structures.</p>
<p>If nested data structures can be shredded into columns, then it is possible<br>
to use a SQL or DataFrame interface to query nested data. All the built-in<br>
optimizations which are available for relational data also then becomes<br>
available to nested data structures. The ability to interactively query millions<br>
or billions of nested data becomes possible in a single node using a vectorized<br>
query execution engines like DuckDB, ClickHouse or Apache DataFusion.</p>
<pre><code># First record
ProductId: 123
ImageGallery:
  PrimaryImageId: 555
  AdditionalImageId:
    - 556
    - 557

# Second record
ProductId: 678
ImageGallery:
  PrimaryImageId: 987
  AdditionalImageId:
    - 988
    - 989
    - 990
</code></pre>
<p>Nested data structures are tree shaped. The atomic or primitive value is<br>
found at the leaf of the tree. And columns in the nested data structure is<br>
the path from root to leaf. The columns with their data type are:</p>
<ol>
<li>ProductId - Integer</li>
<li>ImageGallery.PrimaryImageId - Integer</li>
<li>ImageGallery.AdditionalImageId - Array[Integer]</li>
</ol>
<p>The two records above after being shredded into column values will look like<br>
this:</p>
<pre><code>ProductId                       : [123, 678]
ImageGallery.PrimaryImageId     : [555, 987]
ImageGallery.AdditionalImageId  : [556, 557, 988, 989, 990]
</code></pre>
<p>In the absence of other metadata it is now impossible for us to reassemble<br>
the original records. The structural information is lost with this encoding.<br>
We are unable to identify where a record begins or ends when the nested data<br>
structure contains repeated (array) values. In this representation it is not<br>
possible anymore to know which values in <code>ImageGallery.AdditionalImageId</code><br>
belongs to which records.</p>
<pre><code># First record
ProductId: 123
ImageGallery:
  PrimaryImageId: 555
  AdditionalImageId:
    - 556
    - 557
AltText:
  - Language:
      - Locale: en-US
        Description: Athletic running shoes
        Keyword:
          - shoes
          - running
          - athletic

# Second record
ProductId: 678
ImageGallery:
  PrimaryImageId: 987
  AdditionalImageId:
    - 988
    - 989
    - 990
</code></pre>
<p>Real world nested data structures are also sparse. In this example the<br>
first nested data contains descriptive text columns, but the second record<br>
does not. For partially or completely missing paths in a nested data<br>
structure NULL values are inserted. The more sparse the data because of<br>
missing column values, the more NULL values there will be.</p>
<pre><code>ProductId                       : [123, 678]
ImageGallery.PrimaryImageId     : [555, 987]
ImageGallery.AdditionalImageId  : [556, 557, 988, 989, 990]

# Columns present only in the first record
AltText.Language.Locale         : [&quot;en-US&quot;, NULL]
AltText.Language.Description    : [&quot;Athletic running shoes&quot;, NULL]
AltText.Language.Keyword        : [&quot;shoes&quot;, &quot;running&quot;, &quot;athletic&quot;, NULL]
</code></pre>
<p>The Dremel (Google BigQuery) paper (VLDB 2010) introduced a new<br>
representation for nested data in columnar storage which also stored the<br>
structural hierarchy of the nested data side by side with the column values.<br>
This metadata made it possible to reassemble the original nested data<br>
structure back from columnar format.</p>
<p>The ability to represent nested data directly in a columnar format meant<br>
increased developer productivity. There is no need to normalize the nested<br>
data by extracting entities and joining multiple relations using foreign<br>
keys in some star or snowflake schema for data analysis. Developers could<br>
use the SQL query execution for interactive analysis of very large nested<br>
datasets.</p>
<p>Later when Parquet was created it added ground up support nested data<br>
structures in its file format using the techniques and principles described<br>
in the Dremel paper.</p>
<p>For the <code>ImageGallery.AdditionalImageId</code> it was impossible to reassemble the<br>
original two records by looking at only the stored column values. In Dremel<br>
they introduced metadata which encodes the structure of the values in the<br>
nested data. They are definition level and repetition level.</p>
<p>In the below example by reading <code>d</code> (definition level) and <code>r</code> (repetition<br>
level) in tandem with the column values the original nested values can be<br>
reassembled.</p>
<pre><code># ImageGallery.AdditionalImageId Column  

d       : [1, 1, 1, 1, 1]             # definition level
r       : [0, 1, 0, 1, 1]             # repetition level
values  : [556, 557, 988, 989, 990]
</code></pre>
<p>To compute the definition level of <code>ImageGallery.AdditionalImageId</code> we need<br>
to count all the optional and repeated fields in it. To compute the<br>
repetition level the index of the value must be known. If there are multiple<br>
repeated fields in column path, then the computed repetition level of the<br>
nearest repeated ancestor.</p>
<p>The schema of the nested data is required for us to know if a field is<br>
defined as required, optional or repeated. So let us inspect the schema for<br>
<code>ProductImages</code> document before formalizing the computation of definition<br>
and repetition levels from the nested data.</p>
<p>The schema for <code>ProductImages</code> is given below. From the schema we can see that<br>
this is a nested document which contains the display images for a product and<br>
language translations of the image descriptions.</p>
<p>The data model is,</p>
<ul>
<li>A field is either a struct type or a primitive type like an integer,<br>
string, float, boolean etc.</li>
<li>A field with no explicit multiplicity labels is a required field. A<br>
required field will always be present in the nested data.</li>
<li>An optional field is explicitly marked in the schema. In nested data this<br>
field maybe present or absent.</li>
<li>A repeated field is represented as an array of values. The type of<br>
repeated field can be either a struct type or a primitive type.</li>
<li>The ordering of repeated values is significant.</li>
<li>The leaf node is always a primitive type, or a repeated field of a<br>
primitive type.</li>
<li>A column name is represented using dot notation by joining the field names<br>
from root to leaf. Eg. <code>AltText.Language.Keyword</code></li>
<li></li>
</ul>
<pre><code>ProductImages                     # Document Name
├─ ProductId [int64]               
├─ ImageGallery                   
│  ├─ PrimaryImageId [int64]      
│  └─ AdditionalImageId [int64]*  # repeated
└─ AltText?                       # optional
   └─ Language*                   # repeated
      ├─ Locale [string]          
      ├─ Description [string]?    # optional
      └─ Keyword [string]*        # repeated

* = repeated
? = optional
</code></pre>
<p>A definition level for a column value is computed by counting the occurrence<br>
of optional and repeated fields which are present in the value. If an optional<br>
field is absent then we do not increment the definition level. If a repeated<br>
field is empty or missing we do not increment the definition level. So the<br>
definition level can tell us where the path in a tree terminated for any<br>
given column value.</p>
<p>But this is not enough for us to reassemble repeated values. The repetition<br>
level is used to identify the beginning of an array from the rest of the<br>
array values. For computing repetition levels, only repeated fields in a<br>
path are counted.</p>
<p>In <code>ImageGallery.AdditionalImageId</code>,</p>
<ul>
<li><code>ImageGallery</code> is a required field</li>
<li><code>AdditionalImageId</code> is a repeated field</li>
</ul>
<pre><code># ImageGallery.AdditionalImageId Column  

definition_levels : [1, 1, 1, 1, 1]
repetition_levels : [0, 1, 0, 1, 1]
values            : [556, 557, 988, 989, 990]
</code></pre>
<p>From the definition levels we can see that for all values the path is<br>
<code>ImageGallery.AdditionalImageId</code> because the definition level is 1 which<br>
means the repeated field <code>AdditionalImageId</code> in the path is always present.</p>
<p>There is only a single repeated field, so the repetition levels can be<br>
either zero or one. To identify the start of the array, the first element in<br>
this example will have a repetition level of zero. The remaining values in<br>
the array will have the repetition level of one. So <code>556</code> has repetition level<br>
of zero, and <code>557</code> has a repetition level of one.</p>
<p>For the next value <code>988</code> we can infer that it belongs to the second record<br>
because it has a repetition level of zero. This means it has to be the first<br>
value in the array. And the remaining values in the second record <code>989</code>, <code>989</code><br>
because they have a repetition level of 1.</p>
<p>In this example we were able to identify that the repeated values belonged<br>
to two separate nested values using the repetition levels.</p>
<p>Next let us look at a example which contains null values.</p>
<pre><code>ProductId: 123
ImageGallery:
  PrimaryImageId: 555
  AdditionalImageId:
    - 556
    - 557
AltText:
  - Language:
      - Locale: en-US
        Description: Athletic running shoes
        Keyword:
          - shoes
          - athletic
  - Language:
      - Locale: en-GB
        Description: Athletic trainers
        Keyword:
          - trainers
          - sport
  - Language:
      - Locale: fr-FR
  - Language:
      - Locale: de-DE
</code></pre>
<p>The column <code>AltText.Language.Description</code> contains a repeated field and<br>
exactly two optional fields. The definition level therefore can be between 0<br>
and 3.</p>
<ul>
<li>AltText: optional</li>
<li>Language: repeated</li>
<li>Description: optional</li>
</ul>
<p>After compiling the column values, there are two NULL values. This<br>
represents the missing <code>Description</code> in the 2nd and 3rd <code>Language</code><br>
repetition which corresponds to the <code>Locale</code>: <code>fr-FR</code> and <code>de-DE</code>.</p>
<pre><code># AltText.Language.Description Column

values: [&quot;Athletic running shoes&quot;, &quot;Athletic trainers&quot;, NULL, NULL] 
</code></pre>
<p>Next let us compute the definition levels. The definition level for both the<br>
NULL values is two because the path terminates at <code>AltText.Language</code> as the<br>
<code>Description</code> field is missing in both cases.</p>
<pre><code># AltText.Language.Description Column

definition_levels : [3, 3, 2, 2]
values            : [&quot;Athletic running shoes&quot;, &quot;Athletic trainers&quot;, NULL, NULL] 
</code></pre>
<p>Next let us compute the repetition levels. This column has a single repeated<br>
field which is <code>Language</code>. So repetition levels will be between 0 and 1 for<br>
all values.</p>
<p>Here the repetition level of zero clearly identifies the first element in<br>
the repeated field <code>Language</code>, from the rest.</p>
<pre><code># AltText.Language.Description Column

repetition_levels : [0, 1, 1, 1]
definition_levels : [3, 3, 2, 2]
values            : [&quot;Athletic running shoes&quot;, &quot;Athletic trainers&quot;, NULL, NULL] 
</code></pre>
<p>Next let us look at an example where there is more than one repeated field<br>
in a column. The <code>AltText.Language.Keyword</code> column has two repeated fields<br>
and a single optional field.</p>
<p>Let us compile the values first. The final two NULL values represent the<br>
missing <code>Keyword</code> in the second and third repetition of <code>Language</code>.</p>
<pre><code># AltText.Language.Keywords

values: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;, NULL, NULL]
</code></pre>
<p>Next let us compute the definition levels. The NULL values have a definition<br>
level of two because <code>Keyword</code> field is missing.</p>
<pre><code># AltText.Language.Keyword

values: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;, NULL, NULL]
def   : [3, 3, 3, 3, 2, 2] 
</code></pre>
<p>Next let us compute the repetition levels. This looks complicated, but you<br>
will soon see how this exactly reassembles the original nested data structure.</p>
<pre><code># AltText.Language.Keyword

values: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;, NULL, NULL]
def   : [3, 3, 3, 3, 2, 2] 
rep   : [0, 2, 1, 2, 1, 1]
</code></pre>
<p>Let us look at the nested column in isolation and give it index numbers.</p>
<pre><code>AltText:
  - Language:         # Language[0]
        - Keyword:
          - shoes     # Language[0].Keyword[0]
          - athletic  # Language[0].Keyword[0]
  - Language:         # Language[1]
        - Keyword:
          - trainers  # Language[1].Keyword[0]
          - sport     # Language[1].Keyword[1]
  - Language:         # Language[2]
  - Language:         # Language[3]
</code></pre>
<p>There are two repeated fields <code>Alt.Language.Keyword</code> which are <code>Language</code><br>
and then <code>Keyword</code>. So values in this column may have repetition levels - 0,<br>
1 or 2.</p>
<p>The complete path for <code>shoes</code> is <code>Language[0].Keyword[0]</code>. This value is the<br>
first repeated value in the path of this nested data structure. The<br>
repetition level of <code>Language[0]</code> is zero. The repetition level of <code>Keyword [0]</code> is also zero. It inherits the repetition level of the nearest repeated<br>
ancestor.</p>
<p>The second value is <code>athletic</code> with path <code>Language[0].Keyword[1]</code>. The<br>
computed repetition level is two so that we can distinctly identify that<br>
this is not the first item in <code>Keyword</code>. Because this is not the first item<br>
we do not have to consider the repetition level of a repeated ancestor. Here<br>
<code>Keyword</code> field is the second repeated field of this column which is present<br>
and therefore the repetition level is two.</p>
<p>The third value is <code>trainers</code>. It has the path <code>Language[1].Keyword[0]</code>.<br>
Even though this is the first Keyword, it is the second repetition of<br>
Language. So the repetition level of <code>Language[1]</code> is one. And since it is<br>
the first keyword, we inherit that value. So the computed repetition level<br>
is one.</p>
<p>The fourth value is <code>sport</code> and the path is <code>Language[1].Keyword[1]</code>. The<br>
computed repetition level is two here. This is the second keyword, and so<br>
the repetition level is same as the number of repeated fields in this path<br>
which happens to be two.</p>
<p>The fifth and sixth values are both NULL. They have the paths <code>Language[2]</code><br>
and <code>Language[3]</code>. The <code>Keyword</code> field is empty or missing. So we compute<br>
the repetition level up to <code>Language</code> field. And the value is one.</p>
<pre><code># AltText.Language.Keyword

values: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;, NULL, NULL]
def   : [3, 3, 3, 3, 2, 2] 
rep   : [0, 2, 1, 2, 1, 1]
</code></pre>
<p>Now that we know how definition and repetition levels are computed, it is<br>
possible to reassemble the nested data structure from the column values,<br>
definition and repetition levels.</p>
<p>From the column storage values we can also reassemble a partial projection of<br>
the nested data structure in its original form. For example if only the<br>
following columns are selected - [ProductId, AltText.Language.Locale] which<br>
is stored in columnar format as,</p>
<pre><code># ProductId Column
values            : [123, 456]
definition_level  : [0, 0]
repetition_level  : [0, 0]

# AltText.Language.Locale
values            : ['en-US', 'en-GB', 'fr-FR', 'de-DE', NULL]
definition_level  : [2, 2, 2, 2, 0]
repetition_level  : [0, 1, 1, 1, 0]
</code></pre>
<p>The reassembled nested data structure resembles the original but contains<br>
only the selected columns.</p>
<pre><code># Record 1
ProductId: 123
AltText:
  - Language:
      - Locale: en-US
  - Language:
      - Locale: en-GB
  - Language:
      - Locale: fr-FR
  - Language:
      - Locale: de-DE

# Record 2
ProductId: 678
</code></pre>
<p>This is just a physical representation. In physical storage the NULL values<br>
can be omitted. Because we know that for the column <code>AltText.Language. Keyword</code> has a max definition level of 3. It has an optional field <code>AltText</code><br>
and two repeated fields <code>Language</code> and <code>Keyword</code>. So when we see a<br>
definition level value lower than 3, we know that it stands for a NULL value.<br>
This way we can avoid storing the NULL values. This is a useful property for<br>
real world nested data structures which are sparse, and therefore has many<br>
NULL values need not be physically stored saving space.</p>
<pre><code># AltText.Language.Keyword

# Logical representation
# values: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;, NULL, NULL]

# Physical representation which does not store NULL values
values: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;]
def   : [3, 3, 3, 3, 2, 2] 
rep   : [0, 2, 1, 2, 1, 1]
</code></pre>
<p>In this example <code>ProductId</code> is a required field so there is no need to store<br>
the definition levels. The definition level is always zero for all values.<br>
Similarly, a definition level of zero implies that the repetition level is<br>
also zero. So we do not also need to store repetition levels.</p>
<pre><code># ProductId Column
values            : [123, 456]
definition_level  : [0, 0]
repetition_level  : [0, 0]
</code></pre>
<p>So in this encoding in physical storage we only write the column values.</p>
<pre><code># ProductId Column
values            : [123, 456]
</code></pre>
<hr>
<p>Draft Notes:</p>
<ul>
<li>Improve definition level explanation: counting number of optional and<br>
repeated fields in the path from root to where the value is found, or<br>
where the path terminates for NULL values or paths which are entirely<br>
missing which can happen if the first field in a path is optional and<br>
therefore is a NULL value.</li>
<li>In <code>AltText.Language.Keyword</code> the computation of repetition levels needs<br>
improvement. For e.g. in the case of &quot;athletic&quot; the second repeated field<br>
<code>Keyword</code> is repeating, therefore the repetition level switches from zero<br>
to two.</li>
<li>The path with index <code>Language[0].Keyword[1]</code> for demonstrating the<br>
relationship with repetition levels can be compiled as a table or a nested<br>
list. The key is to explicitly outline the repetition level no matter<br>
which format is used for visualizing the relationship.</li>
<li>A definition level less than maximum value means a NULL value at that<br>
specific position in the schema. The count provides clues as to where the<br>
path terminated.</li>
<li>Add visual diagrams like in the Twitter blog post - Dremel made simple<br>
with Parquet.</li>
<li>Include an example of a flat schema with a required, optional and repeated<br>
field.</li>
<li>Include bit-level packing of definition, repetition levels.</li>
<li>The twitter blog post includes examples of how useful data structures like<br>
map (key, value) are implemented. It maybe useful to show the separation<br>
between logical and physical types. Map is a logical type which is<br>
rewritten to a struct physical type with a required key of type string,<br>
and an optional value of a primitive type or a record type.</li>
<li>The twitter blog post also includes a nested list example for<br>
demonstrating repetition levels. I need to reference it again to check how<br>
it is represented logically similar to the map type.</li>
<li>Include a couple of practical SQL query examples over the column<br>
shredded nested data structures using Apache DataFusion. The test data can<br>
be generated and written using python to Parquet format.</li>
<li>Parquet precomputed offset index which helps with deeply nested<br>
documents where otherwise we have to scan the definition, repetition<br>
levels from beginning to end to jump to a record. Include a concrete<br>
example.</li>
<li>Include record reassembly as a separate example instead of merging it with<br>
the explanation of definition, and repetition levels.</li>
<li>Schema merging in Parquet. Include an example.</li>
<li>In proto3 there is a significant change. Fields are optional by default<br>
and need not be marked as optional. They don't use the optional keyword<br>
anymore. The paper uses the proto2 syntax and semantics. The optional<br>
fields are explicitly marked. So proto3 removed required fields and uses<br>
default values for missing fields instead of explicitly tracking presence.<br>
This means it is not possible anymore to identify if a field which was<br>
explicitly set to default value vs one which was not set at all. But this<br>
change was included to make it possible to mark an optional field as<br>
required (dangerous) made it challenging for schema evolution. But proto3<br>
reintroduced the optional keyword again.</li>
<li>Include concrete SQL example for predicate pushdown.</li>
<li>Include Zero-Copy Optimization when reading from Parquet to Arrow.<br>
Remapping definition levels to validity bitmaps, and repetition levels to<br>
offset indexes. The last entry (n+1 for n items) indicates position after<br>
the last element. This also has to do with point access when you want to<br>
read all the values for record N, you can do offset[N-1] - offset[N] and<br>
directly read only those values from offset[N-1].</li>
<li>This is not a post about light-weight compression schemes, so I am not<br>
adding anything about dictionary encoding, run-length encoding etc.</li>
</ul>
<hr>
<p>Predicate Pushdown for Nested Fields - Concrete Example<br>
Consider a schema with nested e-commerce orders:<br>
Order<br>
├─ OrderId<br>
├─ Customer<br>
│ ├─ CustomerId<br>
│ ├─ Name<br>
│ └─ PremiumStatus<br>
└─ Items [array]<br>
├─ ProductId<br>
├─ Quantity<br>
└─ Price<br>
Let's say we want all orders where any item has a price over $100:</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><br><span class="token keyword">FROM</span> orders<br><span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> UNNEST<span class="token punctuation">(</span>items<span class="token punctuation">)</span> <span class="token keyword">WHERE</span> price <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span></code></pre>
<p>Traditional Approach:</p>
<p>Read all columns for all Order records<br>
Reconstruct the full nested structure<br>
Apply the filter to each record<br>
Return matching records</p>
<p>Predicate Pushdown with Nested Fields:</p>
<p>The query engine identifies that only the Items.Price column needs examining<br>
first<br>
It reads only the Items.Price column with its definition and repetition levels<br>
It creates a bitmap of which Orders have at least one item with price &gt; $100<br>
It then only reads the remaining columns for Orders that matched the filter</p>
<p>For a dataset with 1 million orders but only 5% having items over $100, this<br>
approach reads only 5% of the data for most columns.</p>
<hr>

<hr>
<ul><li>Previous: <a href="/posts/fourthpost/">This is my fourth post.</a></li>
</ul>

    </main>

    <footer></footer>

    <!-- Current page: /posts/dremel-column-striping/ -->
  </body>
</html>
