<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cache-Friendly B+Tree Nodes With Dynamic Fanout</title>
    <meta name="description" content="On database building blocks.">
    <meta name="generator" content="Eleventy v1.0.1">
    <link rel="stylesheet" href="/css/prism-okaidia.css">
    <link rel="stylesheet" href="/css/custom.css">
    <link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="">
    <link rel="alternate" href="/feed/feed.json" type="application/json" title="">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inria+Serif:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
    <script>document.documentElement.classList.remove("no-js");</script>
  </head>
  <body>
    <div class="page-wrapper">
      <header>
        <hgroup>
        <h3 class="home"><a href="/">Jacob&#39;s blog</a></h3>
        <p>On database building blocks.</p>
      </hgroup>
        <ul class="nav">
          <li class="nav-item"><a href="/">posts</a></li>
          <li class="nav-item"><a href="/about/">whoami</a></li>
        </ul>
      </header>

      <main class="tmpl-post">
        
  <style>
    .draft-notice {
      padding: 0.75rem 0; /* Adds needed spacing */      
      border-block: 2px dashed; 
      font-style: italic;
    }
    .draft-notice p {
      margin: 0; /* Removes default paragraph margin */
    }
  </style>

  <aside class="draft-notice">
    <p>This is a draft preview. To publish, remove <code>draft: true</code> from the front matter.</p>
  </aside>


<h1>Cache-Friendly B+Tree Nodes With Dynamic Fanout</h1>

<time datetime="2025-08-18">18 Aug 2025</time>

<p>The ideal memory layout for a B+Tree node is one in which both the header and data is stored contiguously in a block of memory. This rules out using an <code>std::vector</code> for storing the node data because of the pointer indirection. The <code>std::vector</code> is a pointer to the data, which is stored in a separate block of memory on the heap. We need fine-grained control over how memory is allocated for a B+Tree node.</p>
<p>Using an array instead presents another immediate challenge. A standard member array like <code>entries[N]</code> requires <code>N</code> to be a compile-time constant. Hard-coding commonly used combinations though plausible, is not an ideal workaround. B+Tree are often initialized with different configuration for leaf nodes and inner nodes. This prevents user-configurable node fanout.</p>
<p>The general problem is being able to have fine-grained control over memory layout when a member is a variable-length sequence. This pattern appears often in a format with a fixed header section followed by a variable-length data section. At first when you encounter this problem, it is non-obvious how to write a program which compiles without memory indirection.</p>
<nav class="toc" aria-labelledby="toc-heading">
  <h2 id="toc-heading">Table of Contents</h2>
  <ol>
    <li><a href="#the-struct-hack">The Struct Hack</a></li>
    <li><a href="#b+tree-node-declaration">B+Tree Node Declaration</a></li>
    <li><a href="#raw-memory-buffer">Raw Memory Buffer</a></li>
    <li>
      <a href="#the-price-of-fine-grained-control">The Price Of Fine-Grained Control</a>
      <ul>
        <li><a href="#manual-handling-of-deallocation">Manual Handling Of Deallocation</a></li>
        <li><a href="#adding-new-members-in-a-derived-class">Adding New Members In A Derived Class</a></li>
        <li><a href="#reinventing-the-wheel">Reinventing The Wheel</a></li>
        <li><a href="#hidden-data-type-assumptions">Hidden Data Type Assumptions</a></li>
      </ul>
    </li>
  </ol>
</nav>
<h2 id="the-struct-hack" tabindex="-1">The Struct Hack <a class="direct-link" href="#the-struct-hack" aria-hidden="true">#</a></h2>
<p>The solution to the this problem is a technique which originates in C programming known as the struct hack. The variable-length member (implemented as an array) is placed at the last position in a struct. To satisfy the compiler a size of <code>1</code> is specified, so the array size is known at compilation time.</p>
<pre class="language-c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Payload</span> <span class="token punctuation">{</span><br>  <span class="token comment">/* Header Section */</span><br>  <span class="token comment">// ...</span><br><br>  <span class="token comment">/* Data Section */</span><br><br>  <span class="token comment">// The variable-length member is in last position.</span><br>  <span class="token comment">// The size `1` satisfies the compiler.</span><br>  <span class="token keyword">char</span> elements<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>Then during runtime when you know <code>N</code> you allocate a single block of memory for both the struct and the <code>N</code> elements. To the compiler this is an opaque block, and it cannot provide any guarantees. But writing past the struct is safe because the variable-length member is in the last position.</p>
<pre class="language-c"><code class="language-c"><span class="token comment">// The (N - 1) adjusts for the 1-element array in Payload struct</span><br>Payload <span class="token operator">*</span>item <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Payload<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>This pattern is officially supported in the language since C99, called a <a href="https://en.wikipedia.org/wiki/Flexible_array_member">flexible array member</a>.</p>
<p>The C++11 standard includes the flexible array member.</p>
<blockquote>
<p><strong>Arrays of unknown bound</strong></p>
<p>If <code>expr</code> is omitted in the declaration of an array, the type declared is &quot;array of unknown bound of T&quot;, which is a kind of incomplete type, ...</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">extern</span> <span class="token keyword">int</span> x<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// the type of x is "array of unknown bound of int"</span><br><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// the type of a is "array of 3 int"</span></code></pre>
</blockquote>
<p>The size can be omitted from the array declaration <code>element[]</code>. The code will compile.</p>
<h2 id="b+tree-node-declaration" tabindex="-1">B+Tree Node Declaration <a class="direct-link" href="#b+tree-node-declaration" aria-hidden="true">#</a></h2>
<p>Using the flexible array member syntax, we can now declare a B+Tree node with a memory layout which is a continuous single block in the heap.</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">KeyType</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">ValueType</span><span class="token operator">></span><br><span class="token keyword">class</span> <span class="token class-name">BPlusTreeNode</span> <span class="token punctuation">{</span><br><span class="token keyword">public</span><span class="token operator">:</span><br>  <span class="token keyword">using</span> KeyValuePair <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>KeyType<span class="token punctuation">,</span> ValueType<span class="token operator">></span><span class="token punctuation">;</span><br><br><span class="token keyword">private</span><span class="token operator">:</span><br>  <span class="token comment">// Node Header Members ... (elided)</span><br><br>  <span class="token comment">// Points to the memory location beyond the last key-value</span><br>  <span class="token comment">// entry in the `start_` array.</span><br>  KeyValuePair<span class="token operator">*</span> end_<span class="token punctuation">;</span><br><br>  <span class="token comment">// Array containing key-value entries of unknown bound.</span><br>  KeyValuePair start_<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>Instead if we use a <code>std::vector&lt;KeyValuePair&gt;</code> for the B+Tree node data. This stores a pointer in the struct, with the node data resident in a separate block of memory in another part of the heap.</p>
<p>Now accessing the node data can be significantly slower because of the pointer indirection. Following the pointer will increase cache misses, forcing the CPU to stall and wait for data to be fetched from main memory. A cache miss may cost hundreds of CPU cycles compared to just a cycles for a cache hit. This performance hit though is unacceptable if you need high-performance from your B+Tree implementation.</p>
<p>So we go through all this trouble to avoid pointer indirection and co-locate both the header and data of a B+Tree node in the same memory block. This layout is cache-friendly and improves B+Tree performance.</p>
<h2 id="raw-memory-buffer" tabindex="-1">Raw Memory Buffer <a class="direct-link" href="#raw-memory-buffer" aria-hidden="true">#</a></h2>
<p>This is the key step. The construction of the object has to be separate from its memory allocation. For this we cannot use the standard <code>new</code> syntax which will attempt to allocate storage, and then initialize the object in this storage.</p>
<p>Instead we will use the <a href="https://en.cppreference.com/w/cpp/language/new.html#Placement_new">placement new</a> syntax which will construct objects in the memory buffer specified by us.</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token comment">// A static helper to allocate storage for a B+Tree node.</span><br><span class="token keyword">static</span> BPlusTreeNode <span class="token operator">*</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token keyword">int</span> p_fanout<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// calculate total buffer size</span><br>  size_t buf_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>BPlusTreeNode<span class="token punctuation">)</span> <span class="token operator">+</span> p_fanout <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>KeyValuePair<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// allocate raw memory buffer</span><br>  <span class="token keyword">void</span> <span class="token operator">*</span>buf <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>buf_size<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// construct B+Tree node object in the preallocated buffer</span><br>  <span class="token keyword">auto</span> node <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token function">BPlusTreeNode</span><span class="token punctuation">(</span>p_fanout<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">return</span> node<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>We have now successfully created a cache-friendly B+Tree node with a user-defined fanout configuration which is known only at runtime.</p>
<h2 id="the-price-of-fine-grained-control" tabindex="-1">The Price Of Fine-Grained Control <a class="direct-link" href="#the-price-of-fine-grained-control" aria-hidden="true">#</a></h2>
<p>To create an instance, we can no longer simply write <code>new BPlusTreeNode(256)</code>. Instead we have to use our custom helper which knows how much raw memory to allocate for the object including the data section.</p>
<pre class="language-cpp"><code class="language-cpp">BPlusTreeNode <span class="token operator">*</span>root <span class="token operator">=</span> <span class="token class-name">BPlusTreeNode</span><span class="token operator">&lt;</span>KeyValuePair<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="manual-handling-of-deallocation" tabindex="-1">Manual Handling Of Deallocation <a class="direct-link" href="#manual-handling-of-deallocation" aria-hidden="true">#</a></h3>
<p>We also need to handle object deallocation, so that when the lifetime of the object ends, the memory is freed to avoid memory leaks.</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BPlusTreeNode</span> <span class="token punctuation">{</span><br><br>  <span class="token keyword">void</span> <span class="token function">FreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Call the destructor for each key-value entry.</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>KeyValuePair<span class="token operator">*</span> element <span class="token operator">=</span> start_<span class="token punctuation">;</span> element <span class="token operator">&lt;</span> end_<span class="token punctuation">;</span> <span class="token operator">++</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      element<span class="token operator">-></span><span class="token operator">~</span><span class="token function">KeyValuePair</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// Call the node destructor</span><br>    <span class="token keyword">this</span><span class="token operator">-></span><span class="token operator">~</span><span class="token function">BPlusTreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Deallocate the raw memory</span><br>    <span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<h3 id="adding-new-members-in-a-derived-class" tabindex="-1">Adding New Members In A Derived Class <a class="direct-link" href="#adding-new-members-in-a-derived-class" aria-hidden="true">#</a></h3>
<p>Adding a new member to a derived class will result in data corruption.</p>
<pre class="language-text"><code class="language-text">+-----------------------+<br>| BPlusTreeNode Members |<br>| (Header)              |<br>+-----------------------+ <-- offset where the data buffer starts<br>| start_[0]             | <-- where the compiler thinks derived class<br>| start_[1]             |     member are written to<br>| ...                   |<br>| start_[N]             |<br>+-----------------------+ <-- end_</code></pre>
<p>The raw memory we manually allocated is opaque to the compiler and it cannot safely reason about where the newly added members to the derived class are physically located. The end result is it will overwrite the data buffer and cause data corruption.</p>
<p>The workaround is to break encapsulation and add derived members to the base class so that the flexible array member is always in the last position. This is a significant drawback when we begin using flexible array members.</p>
<h3 id="reinventing-the-wheel" tabindex="-1">Reinventing The Wheel <a class="direct-link" href="#reinventing-the-wheel" aria-hidden="true">#</a></h3>
<p>We lose RAII guarantees provided by the compiler and runtime bounds checking in <code>std::vector</code>.</p>
<p>We now bear the full responsibility of manually implementing, testing and maintaining the code for utility functions like insertion, deletion and iteration. The bounds-checking code to prevent buffer overflows requires verification.</p>
<h3 id="hidden-data-type-assumptions" tabindex="-1">Hidden Data Type Assumptions <a class="direct-link" href="#hidden-data-type-assumptions" aria-hidden="true">#</a></h3>
<p>The following is an implementation for inserting a <code>KeyValuePair</code> element in the data array.</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> KeyValuePair <span class="token operator">&amp;</span>element<span class="token punctuation">,</span> KeyValuePair <span class="token operator">*</span>pos<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// The node is currently full so we cannot insert this element.</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GetCurrentSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token function">GetMaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><br><br>  <span class="token comment">// Shift elements from `pos` to the right by one to make</span><br>  <span class="token comment">// place for inserting new `element`.</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> <span class="token function">End</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      std<span class="token double-colon punctuation">::</span><span class="token function">memmove</span><span class="token punctuation">(</span><br>        <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">next</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// Destination</span><br>        <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// Source</span><br>        std<span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> <span class="token function">End</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>KeyValuePair<span class="token punctuation">)</span> <span class="token comment">// Count</span><br>      <span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token comment">// Insert element at `pos`.</span><br>  <span class="token keyword">new</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span> KeyValuePair<span class="token punctuation">{</span>element<span class="token punctuation">}</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// Bookkeeping</span><br>  std<span class="token double-colon punctuation">::</span><span class="token function">advance</span><span class="token punctuation">(</span>end_<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>The code above uses <code>std::memmove</code> to shift entries within the node. This introduces a hidden constraint, that the data types implementing the <code>BPlusTreeNode</code> should be POD (plain old data) types or trivially copyable.</p>
<p>The class interface is generic over the key and value types. But it doesn't convey this constraint to the user of the <code>BPlusTreeNode</code>.</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">KeyType</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">ValueType</span><span class="token operator">></span><br><span class="token keyword">class</span> <span class="token class-name">BPlusTreeNode</span> <span class="token punctuation">{</span><br><span class="token keyword">public</span><span class="token operator">:</span><br>  <span class="token keyword">using</span> KeyValuePair <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>KeyType<span class="token punctuation">,</span> ValueType<span class="token operator">></span><span class="token punctuation">;</span><br><br>  <span class="token comment">// ...</span><br><span class="token punctuation">}</span></code></pre>
<p>If we used <code>std::string</code> as either the <code>KeyType</code> or <code>ValueType</code> then calling the <code>Insert</code> method introduces undefined behavior. Copying a <code>std::string</code> object with <code>memmove</code> creates a shallow copy of its internal pointers. When the original string is destroyed, it will deallocate the memory, leaving the copied string with a dangling pointer.</p>


      </main>

      <footer></footer>

      <!-- Current page: /posts/btree-node-struct-hack/ -->
    </body>
  </div>
</html>
