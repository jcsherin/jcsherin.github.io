<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dremel: Interactive Analysis of Web-Scale Datasets</title>
    <meta name="description" content="Column-striping of nested records">
    <meta name="generator" content="Eleventy v1.0.1">

    <link rel="stylesheet" href="/css/index.css">
    <link rel="stylesheet" href="/css/prism-base16-monokai.dark.css">
    <link rel="stylesheet" href="/css/prism-diff.css">
    <link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="jcsherin">
    <link rel="alternate" href="/feed/feed.json" type="application/json" title="jcsherin">
  </head>
  <body>
    <header>
      <h1 class="home"><a href="/">jcsherin</a></h1>
      <ul class="nav">
        <li class="nav-item"><a href="/">Home</a></li>
        <li class="nav-item"><a href="/posts/">Archive</a></li>
        <li class="nav-item"><a href="/about/">About Me</a></li>
      </ul>
    </header>

    <main class="tmpl-post">
      <h1>Dremel: Interactive Analysis of Web-Scale Datasets</h1>

<time datetime="2025-02-16">16 Feb 2025</time><a href="/tags/columnar-storage/" class="post-tag">columnar storage</a>

<ul>
<li>What is Dremel?</li>
<li>This paper introduces a novel column storage representation for nested records</li>
<li>Nested records are non-relational</li>
<li>What kind of data tends naturally to a nested representation?
<ul>
<li>Data-structures in programming languages</li>
<li>Messages exchanged by distributed systems</li>
<li>Structured documents</li>
</ul>
</li>
<li>Why is ad-hoc query difficult on nested records?</li>
</ul>
<blockquote>
<p>Normalizing and recombining such data at web scale is usually prohibitive.</p>
</blockquote>
<ul>
<li>Normalizing -&gt; splitting a record into multiple relations</li>
<li>Recombining -&gt; multi join queries</li>
<li>Dremel provides a SQL-like language to express ad-hoc queries</li>
</ul>
<blockquote>
<p>Dremel uses a column-striped storage representation, which enables it to
read less data from secondary storage and reduce CPU cost due to cheaper
compression.</p>
</blockquote>
<ul>
<li>The main contribution of this paper is a columnar storage for nested data.</li>
<li>It describes algorithms for column-striping strongly-typed nested data and
also reassembly of nested data from a given projection of columns</li>
<li>The Dremel query execution can operate directly on the column-striped
values to run ad-hoc aggregation queries over many nested records without
any further restructuring of the data.</li>
<li>How does this look?
<ul>
<li>record wise vs columnar representation of data</li>
</ul>
</li>
<li>What are the challenges?
<ul>
<li>How to preserve all the structural information?</li>
<li>Be able to reconstruct records from an arbitrary subset of fields</li>
</ul>
</li>
<li>Data Model
<ul>
<li>Strongly-typed nested records</li>
<li>Protocol Buffers syntax because that is used in Google</li>
<li>Atomic types and nested records</li>
<li>Records have one or more fields
<ul>
<li>Field has an optional multiplicity label
<ul>
<li>Optional fields maybe missing</li>
<li>Otherwise a field is required and should be present</li>
</ul>
</li>
<li>Repeated fields may occur multiple times in a record
<ul>
<li>list of values</li>
<li>order of field occurrences (list item position) is significant</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="nested-columnar-storage" tabindex="-1">Nested Columnar Storage <a class="direct-link" href="#nested-columnar-storage" aria-hidden="true">#</a></h2>
<p>Challenges:</p>
<ol>
<li>Lossless representation of record structure in columnar format</li>
<li>fast encoding</li>
<li>efficient reassembly</li>
</ol>
<blockquote>
<p>Values alone do not convey the structure of a record. Given two values of a
repeated field, we do not know at what ‘level’ the value repeated (e.g.,
whether
these values are from two different records, or two repeated values in the
same
record). Likewise, given a missing optional field, we do not know which
enclosing records were defined explicitly. (p. 3)</p>
</blockquote>
<h2 id="repetition-levels" tabindex="-1">Repetition Levels <a class="direct-link" href="#repetition-levels" aria-hidden="true">#</a></h2>
<ul>
<li>Repeated fields are represented as a list of items</li>
</ul>
<blockquote>
<p>It tells us at what repeated field in the field’s path the value has
repeated. (p. 3)</p>
</blockquote>
<ul>
<li>The simplest case is,
<ul>
<li>there are no nested repeated fields</li>
<li>list items are scalar values</li>
</ul>
</li>
<li>The repetition level then tells us,
<ul>
<li>the order of values in a list</li>
<li>it also encodes record boundaries so we know which record a list item
belongs to</li>
</ul>
</li>
<li>In the nested repeated case a path may contain multiple repeated fields</li>
<li>A path can terminate early if the list is empty, but this is not encoded
by repetition levels</li>
<li>How does that all look? (a concrete example for illustration)</li>
<li>And repetition levels then tell us,
<ul>
<li>all the same as in the case of no nesting of repeated fields</li>
<li>and also which paths in the tree a list item belongs to</li>
</ul>
</li>
</ul>
<blockquote>
<p>In general though, determining the level up to which nested records exist
requires extra information.</p>
</blockquote>
<ul>
<li>Is that a forward reference to definition levels?</li>
</ul>
<h2 id="definition-levels" tabindex="-1">Definition Levels <a class="direct-link" href="#definition-levels" aria-hidden="true">#</a></h2>
<blockquote>
<p>Each value of a field with path p, esp. every NULL, has a definition level
specifying how many fields in p that could be undefined (because they are
optional or repeated) are actually present in the record.</p>
</blockquote>
<blockquote>
<p>We use integer definition levels as opposed to is-null bits so that the data
for a leaf field (e.g., Name.Language.Country) contains the information about
the occurrences of its parent fields; (p. 3)</p>
</blockquote>
<ul>
<li>A concrete example for illustration</li>
</ul>
<h2 id="encoding" tabindex="-1">Encoding <a class="direct-link" href="#encoding" aria-hidden="true">#</a></h2>
<h2 id="splitting-records-into-columns" tabindex="-1">Splitting Records into Columns <a class="direct-link" href="#splitting-records-into-columns" aria-hidden="true">#</a></h2>
<h2 id="record-assembly" tabindex="-1">Record Assembly <a class="direct-link" href="#record-assembly" aria-hidden="true">#</a></h2>
<h2 id="not-particularly-interesting-to-me-(so-maybe)" tabindex="-1">Not Particularly Interesting To Me (So maybe) <a class="direct-link" href="#not-particularly-interesting-to-me-(so-maybe)" aria-hidden="true">#</a></h2>
<ul>
<li>Query Language</li>
<li>Distributed Query Execution</li>
</ul>


    </main>

    <footer></footer>

    <!-- Current page: /papers/2025-02-16-dremel-column-striping-nested-records/ -->
  </body>
</html>
