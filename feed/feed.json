{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "jcsherin",
  "language": "en",
  "home_page_url": "https://jacobsherin.com/",
  "feed_url": "https://example.com/feed/feed.json",
  "description": "jcsherin writes about programming",
  "author": {
    "name": "Your Name Here",
    "url": "https://example.com/about-me/"
  },
  "items": [{
      "id": "https://jacobsherin.com/posts/dremel-column-striping/",
      "url": "https://jacobsherin.com/posts/dremel-column-striping/",
      "title": "Nested Record Shredding",
      "content_html": "<p>Notes:</p>\n<ul>\n<li>A lot of engineering effort goes into building a correct, performant<br />\nvectorized query execution engine for analytical workloads. You can use<br />\neither SQL or DataFrames to run interactive analysis over very large<br />\ndatasets. The data is ready to query in a relational form, and PAX storage<br />\nmodel on disk.</li>\n</ul>\n<p>In columnar storage values of a single column attribute are stored<br />\ncontiguously. In analytics databases the query optimizer can apply<br />\nprojection pushdown directly to the data source. This means only those columns<br />\nwhich are specified in the query are read from storage. Analytical queries are<br />\noften aggregations over the entire data source. So this can reduce the I/O<br />\nrequired and make the queries run faster.</p>\n<p>It is easy to map flat relational data to columns. Given a projection of<br />\ncolumns the original record can be reassembled by index or offset. A record<br />\nhas the same index or offset across all columns. This is not the case with<br />\nnested data structures.</p>\n<p>If nested data structures can be shredded into columns, then it is possible<br />\nto use a SQL or DataFrame interface to query nested data. All the built-in<br />\noptimizations which are available for relational data also then becomes<br />\navailable to nested data structures. The ability to interactively query millions<br />\nor billions of nested data becomes possible in a single node using a vectorized<br />\nquery execution engines like DuckDB, ClickHouse or Apache DataFusion.</p>\n<pre><code># First record\nProductId: 123\nImageGallery:\n  PrimaryImageId: 555\n  AdditionalImageId:\n    - 556\n    - 557\n\n# Second record\nProductId: 678\nImageGallery:\n  PrimaryImageId: 987\n  AdditionalImageId:\n    - 988\n    - 989\n    - 990\n</code></pre>\n<p>Nested data structures are tree shaped. The atomic or primitive value is<br />\nfound at the leaf of the tree. And columns in the nested data structure is<br />\nthe path from root to leaf. The columns with their data type are:</p>\n<ol>\n<li>ProductId - Integer</li>\n<li>ImageGallery.PrimaryImageId - Integer</li>\n<li>ImageGallery.AdditionalImageId - Array[Integer]</li>\n</ol>\n<p>The two records above after being shredded into column values will look like<br />\nthis:</p>\n<pre><code>ProductId                       : [123, 678]\nImageGallery.PrimaryImageId     : [555, 987]\nImageGallery.AdditionalImageId  : [556, 557, 988, 989, 990]\n</code></pre>\n<p>In the absence of other metadata it is now impossible for us to reassemble<br />\nthe original records. The structural information is lost with this encoding.<br />\nWe are unable to identify where a record begins or ends when the nested data<br />\nstructure contains repeated (array) values. In this representation it is not<br />\npossible anymore to know which values in <code>ImageGallery.AdditionalImageId</code><br />\nbelongs to which records.</p>\n<pre><code># First record\nProductId: 123\nImageGallery:\n  PrimaryImageId: 555\n  AdditionalImageId:\n    - 556\n    - 557\nAltText:\n  - Language:\n      - Locale: en-US\n        Description: Athletic running shoes\n        Keyword:\n          - shoes\n          - running\n          - athletic\n\n# Second record\nProductId: 678\nImageGallery:\n  PrimaryImageId: 987\n  AdditionalImageId:\n    - 988\n    - 989\n    - 990\n</code></pre>\n<p>Real world nested data structures are also sparse. In this example the<br />\nfirst nested data contains descriptive text columns, but the second record<br />\ndoes not. For partially or completely missing paths in a nested data<br />\nstructure NULL values are inserted. The more sparse the data because of<br />\nmissing column values, the more NULL values there will be.</p>\n<pre><code>ProductId                       : [123, 678]\nImageGallery.PrimaryImageId     : [555, 987]\nImageGallery.AdditionalImageId  : [556, 557, 988, 989, 990]\n\n# Columns present only in the first record\nAltText.Language.Locale         : [&quot;en-US&quot;, NULL]\nAltText.Language.Description    : [&quot;Athletic running shoes&quot;, NULL]\nAltText.Language.Keyword        : [&quot;shoes&quot;, &quot;running&quot;, &quot;athletic&quot;, NULL]\n</code></pre>\n<p>The Dremel (Google BigQuery) paper (VLDB 2010) introduced a new<br />\nrepresentation for nested data in columnar storage which also stored the<br />\nstructural hierarchy of the nested data side by side with the column values.<br />\nThis metadata made it possible to reassemble the original nested data<br />\nstructure back from columnar format.</p>\n<p>The ability to represent nested data directly in a columnar format meant<br />\nincreased developer productivity. There is no need to normalize the nested<br />\ndata by extracting entities and joining multiple relations using foreign<br />\nkeys in some star or snowflake schema for data analysis. Developers could<br />\nuse the SQL query execution for interactive analysis of very large nested<br />\ndatasets.</p>\n<p>Later when Parquet was created it added ground up support nested data<br />\nstructures in its file format using the techniques and principles described<br />\nin the Dremel paper.</p>\n<p>For the <code>ImageGallery.AdditionalImageId</code> it was impossible to reassemble the<br />\noriginal two records by looking at only the stored column values. In Dremel<br />\nthey introduced metadata which encodes the structure of the values in the<br />\nnested data. They are definition level and repetition level.</p>\n<p>In the below example by reading <code>d</code> (definition level) and <code>r</code> (repetition<br />\nlevel) in tandem with the column values the original nested values can be<br />\nreassembled.</p>\n<pre><code># ImageGallery.AdditionalImageId Column  \n\nd       : [1, 1, 1, 1, 1]             # definition level\nr       : [0, 1, 0, 1, 1]             # repetition level\nvalues  : [556, 557, 988, 989, 990]\n</code></pre>\n<p>To compute the definition level of <code>ImageGallery.AdditionalImageId</code> we need<br />\nto count all the optional and repeated fields in it. To compute the<br />\nrepetition level the index of the value must be known. If there are multiple<br />\nrepeated fields in column path, then the computed repetition level of the<br />\nnearest repeated ancestor.</p>\n<p>The schema of the nested data is required for us to know if a field is<br />\ndefined as required, optional or repeated. So let us inspect the schema for<br />\n<code>ProductImages</code> document before formalizing the computation of definition<br />\nand repetition levels from the nested data.</p>\n<p>The schema for <code>ProductImages</code> is given below. From the schema we can see that<br />\nthis is a nested document which contains the display images for a product and<br />\nlanguage translations of the image descriptions.</p>\n<p>The data model is,</p>\n<ul>\n<li>A field is either a struct type or a primitive type like an integer,<br />\nstring, float, boolean etc.</li>\n<li>A field with no explicit multiplicity labels is a required field. A<br />\nrequired field will always be present in the nested data.</li>\n<li>An optional field is explicitly marked in the schema. In nested data this<br />\nfield maybe present or absent.</li>\n<li>A repeated field is represented as an array of values. The type of<br />\nrepeated field can be either a struct type or a primitive type.</li>\n<li>The ordering of repeated values is significant.</li>\n<li>The leaf node is always a primitive type, or a repeated field of a<br />\nprimitive type.</li>\n<li>A column name is represented using dot notation by joining the field names<br />\nfrom root to leaf. Eg. <code>AltText.Language.Keyword</code></li>\n<li></li>\n</ul>\n<pre><code>ProductImages                     # Document Name\n├─ ProductId [int64]               \n├─ ImageGallery                   \n│  ├─ PrimaryImageId [int64]      \n│  └─ AdditionalImageId [int64]*  # repeated\n└─ AltText?                       # optional\n   └─ Language*                   # repeated\n      ├─ Locale [string]          \n      ├─ Description [string]?    # optional\n      └─ Keyword [string]*        # repeated\n\n* = repeated\n? = optional\n</code></pre>\n<p>A definition level for a column value is computed by counting the occurrence<br />\nof optional and repeated fields which are present in the value. If an optional<br />\nfield is absent then we do not increment the definition level. If a repeated<br />\nfield is empty or missing we do not increment the definition level. So the<br />\ndefinition level can tell us where the path in a tree terminated for any<br />\ngiven column value.</p>\n<p>But this is not enough for us to reassemble repeated values. The repetition<br />\nlevel is used to identify the beginning of an array from the rest of the<br />\narray values. For computing repetition levels, only repeated fields in a<br />\npath are counted.</p>\n<p>In <code>ImageGallery.AdditionalImageId</code>,</p>\n<ul>\n<li><code>ImageGallery</code> is a required field</li>\n<li><code>AdditionalImageId</code> is a repeated field</li>\n</ul>\n<pre><code># ImageGallery.AdditionalImageId Column  \n\ndefinition_levels : [1, 1, 1, 1, 1]\nrepetition_levels : [0, 1, 0, 1, 1]\nvalues            : [556, 557, 988, 989, 990]\n</code></pre>\n<p>From the definition levels we can see that for all values the path is<br />\n<code>ImageGallery.AdditionalImageId</code> because the definition level is 1 which<br />\nmeans the repeated field <code>AdditionalImageId</code> in the path is always present.</p>\n<p>There is only a single repeated field, so the repetition levels can be<br />\neither zero or one. To identify the start of the array, the first element in<br />\nthis example will have a repetition level of zero. The remaining values in<br />\nthe array will have the repetition level zero. So <code>556</code> has repetition level<br />\nof zero, and <code>557</code> has a repetition level of one.</p>\n<p>For the next value <code>988</code> we can infer that it belongs to the second record<br />\nbecause it has a repetition level of zero. This means it has to be the first<br />\nvalue in the array. And the remaining values in the second record <code>989</code>, <code>999</code><br />\nbecause they have a repetition level of 1.</p>\n<p>In this example we were able to identify that the repeated values belonged<br />\nto two separate nested values using the repetition levels.</p>\n<p>Next let us look at a example which contains null values.</p>\n<pre><code>ProductId: 123\nImageGallery:\n  PrimaryImageId: 555\n  AdditionalImageId:\n    - 556\n    - 557\nAltText:\n  - Language:\n      - Locale: en-US\n        Description: Athletic running shoes\n        Keyword:\n          - shoes\n          - athletic\n  - Language:\n      - Locale: en-GB\n        Description: Athletic trainers\n        Keyword:\n          - trainers\n          - sport\n  - Language:\n      - Locale: fr-FR\n  - Language:\n      - Locale: de-DE\n</code></pre>\n<p>The column <code>AltText.Language.Description</code> contains a repeated field and<br />\nexactly two optional fields. The definition level therefore can be between 0<br />\nand 3.</p>\n<ul>\n<li>AltText: optional</li>\n<li>Language: repeated</li>\n<li>Description: optional</li>\n</ul>\n<p>After compiling the column values, there are two NULL values. This<br />\nrepresents the missing <code>Description</code> in the 2nd and 3rd <code>Language</code><br />\nrepetition which corresponds to the <code>Locale</code>: <code>fr-FR</code> and <code>de-DE</code>.</p>\n<pre><code># AltText.Language.Description Column\n\nvalues: [&quot;Athletic running shoes&quot;, &quot;Athletic trainers&quot;, NULL, NULL] \n</code></pre>\n<p>Next let us compute the definition levels. The definition level for both the<br />\nNULL values is two because the path terminates at <code>AltText.Language</code> as the<br />\n<code>Description</code> field is missing in both cases.</p>\n<pre><code># AltText.Language.Description Column\n\ndefinition_levels : [3, 3, 2, 2]\nvalues            : [&quot;Athletic running shoes&quot;, &quot;Athletic trainers&quot;, NULL, NULL] \n</code></pre>\n<p>Next let us compute the repetition levels. This column has a single repeated<br />\nfield which is <code>Language</code>. So repetition levels will be between 0 and 1 for<br />\nall values.</p>\n<p>Here the repetition level of zero clearly identifies the first element in<br />\nthe repeated field <code>Language</code>, from the rest.</p>\n<pre><code># AltText.Language.Description Column\n\nrepetition_levels : [0, 1, 1, 1]\ndefinition_levels : [3, 3, 2, 2]\nvalues            : [&quot;Athletic running shoes&quot;, &quot;Athletic trainers&quot;, NULL, NULL] \n</code></pre>\n<p>Next let us look at an example where there is more than one repeated field<br />\nin a column. The <code>AltText.Language.Keyword</code> column has two repeated fields<br />\nand a single optional field.</p>\n<p>Let us compile the values first. The final two NULL values represent the<br />\nmissing <code>Keyword</code> in the second and third repetition of <code>Language</code>.</p>\n<pre><code># AltText.Language.Keywords\n\nvalues: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;, NULL, NULL]\n</code></pre>\n<p>Next let us compute the definition levels. The NULL values have a definition<br />\nlevel of two because <code>Keyword</code> field is missing.</p>\n<pre><code># AltText.Language.Keyword\n\nvalues: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;, NULL, NULL]\ndef   : [3, 3, 3, 3, 2, 2] \n</code></pre>\n<p>Next let us compute the repetition levels. This looks complicated, but you<br />\nwill soon see how this exactly reassembles the original nested data structure.</p>\n<pre><code># AltText.Language.Keyword\n\nvalues: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;, NULL, NULL]\ndef   : [3, 3, 3, 3, 2, 2] \nrep   : [0, 2, 1, 2, 1, 1]\n</code></pre>\n<p>Let us look at the nested column in isolation and give it index numbers.</p>\n<pre><code>AltText:\n  - Language:         # Language[0]\n        - Keyword:\n          - shoes     # Language[0].Keyword[0]\n          - athletic  # Language[0].Keyword[0]\n  - Language:         # Language[1]\n        - Keyword:\n          - trainers  # Language[1].Keyword[0]\n          - sport     # Language[1].Keyword[1]\n  - Language:         # Language[2]\n  - Language:         # Language[3]\n</code></pre>\n<p>There are two repeated fields <code>Alt.Language.Keyword</code> which are <code>Language</code><br />\nand then <code>Keyword</code>. So values in this column may have repetition levels - 0,<br />\n1 or 2.</p>\n<p>The complete path for <code>shoes</code> is <code>Language[0].Keyword[0]</code>. This value is the<br />\nfirst repeated value in the path of this nested data structure. The<br />\nrepetition level of <code>Language[0]</code> is zero. The repetition level of <code>Keyword [0]</code> is also zero. It inherits the repetition level of the nearest repeated<br />\nancestor.</p>\n<p>The second value is <code>athletic</code> with path <code>Language[0].Keyword[1]</code>. The<br />\ncomputed repetition level is two so that we can distinctly identify that<br />\nthis is not the first item in <code>Keyword</code>. Because this is not the first item<br />\nwe do not have to consider the repetition level of a repeated ancestor. Here<br />\n<code>Keyword</code> field is the second repeated field of this column which is present<br />\nand therefore the repetition level is two.</p>\n<p>The third value is <code>trainers</code>. It has the path <code>Language[1].Keyword[0]</code>.<br />\nEven though this is the first Keyword, it is the second repetition of<br />\nLanguage. So the repetition level of <code>Language[1]</code> is one. And since it is<br />\nthe first keyword, we inherit that value. So the computed repetition level<br />\nis one.</p>\n<p>The fourth value is <code>sport</code> and the path is <code>Language[1].Keyword[1]</code>. The<br />\ncomputed repetition level is two here. This is the second keyword, and so<br />\nthe repetition level is same as the number of repeated fields in this path<br />\nwhich happens to be two.</p>\n<p>The fifth and sixth values are both NULL. They have the paths <code>Language[2]</code><br />\nand <code>Language[3]</code>. The <code>Keyword</code> field is empty or missing. So we compute<br />\nthe repetition level up to <code>Language</code> field. And the value is one.</p>\n<pre><code># AltText.Language.Keyword\n\nvalues: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;, NULL, NULL]\ndef   : [3, 3, 3, 3, 2, 2] \nrep   : [0, 2, 1, 2, 1, 1]\n</code></pre>\n<p>Now that we know how definition and repetition levels are computed, it is<br />\npossible to reassemble the nested data structure from the column values,<br />\ndefinition and repetition levels.</p>\n<p>From the column storage values we can also reassemble a partial projection of<br />\nthe nested data structure in its original form. For example if only the<br />\nfollowing columns are selected - [ProductId, AltText.Language.Locale] which<br />\nis stored in columnar format as,</p>\n<pre><code># ProductId Column\nvalues            : [123, 456]\ndefinition_level  : [0, 0]\nrepetition_level  : [0, 0]\n\n# AltText.Language.Locale\nvalues            : ['en-US', 'en-GB', 'fr-FR', 'de-DE', NULL]\ndefinition_level  : [2, 2, 2, 2, 0]\nrepetition_level  : [0, 1, 1, 1, 0]\n</code></pre>\n<p>The reassembled nested data structure resembles the original but contains<br />\nonly the selected columns.</p>\n<pre><code># Record 1\nProductId: 123\nAltText:\n  - Language:\n      - Locale: en-US\n  - Language:\n      - Locale: en-GB\n  - Language:\n      - Locale: fr-FR\n  - Language:\n      - Locale: de-DE\n\n# Record 2\nProductId: 678\n</code></pre>\n<p>This is just a physical representation. In physical storage the NULL values<br />\ncan be omitted. Because we know that for the column <code>AltText.Language. Keyword</code> has a max definition level of 3. It has an optional field <code>AltText</code><br />\nand two repeated fields <code>Language</code> and <code>Keyword</code>. So when we see a<br />\ndefinition level value lower than 3, we know that it stands for a NULL value.<br />\nThis way we can avoid storing the NULL values. This is a useful property for<br />\nreal world nested data structures which are sparse, and therefore has many<br />\nNULL values need not be physically stored saving space.</p>\n<pre><code># AltText.Language.Keyword\n\n# Logical representation\n# values: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;, NULL, NULL]\n\n# Physical representation which does not store NULL values\nvalues: [&quot;shoes&quot;, &quot;athletic&quot;, &quot;trainers&quot;, &quot;sport&quot;]\ndef   : [3, 3, 3, 3, 2, 2] \nrep   : [0, 2, 1, 2, 1, 1]\n</code></pre>\n<p>In this example <code>ProductId</code> is a required field so there is no need to store<br />\nthe definition levels. The definition level is always zero for all values.<br />\nSimilarly, a definition level of zero implies that the repetition level is<br />\nalso zero. So we do not also need to store repetition levels.</p>\n<pre><code># ProductId Column\nvalues            : [123, 456]\ndefinition_level  : [0, 0]\nrepetition_level  : [0, 0]\n</code></pre>\n<p>So in this encoding in physical storage we only write the column values.</p>\n<pre><code># ProductId Column\nvalues            : [123, 456]\n</code></pre>\n",
      "date_published": "2025-04-21T00:00:00Z"
    },{
      "id": "https://jacobsherin.com/posts/fourthpost/",
      "url": "https://jacobsherin.com/posts/fourthpost/",
      "title": "This is my fourth post.",
      "content_html": "<p>Leverage agile frameworks to provide a robust synopsis for high level overviews. Iterative approaches to corporate strategy foster collaborative thinking to further the overall value proposition. Organically grow the holistic world view of disruptive innovation via workplace diversity and empowerment.</p>\n<p>Bring to the table win-win survival strategies to ensure proactive domination. At the end of the day, going forward, a new normal that has evolved from generation X is on the runway heading towards a streamlined cloud solution. User generated content in real-time will have multiple touchpoints for offshoring.</p>\n<h2 id=\"section-header\" tabindex=\"-1\">Section Header <a class=\"direct-link\" href=\"https://jacobsherin.com/posts/fourthpost/#section-header\" aria-hidden=\"true\">#</a></h2>\n<p>Capitalize on low hanging fruit to identify a ballpark value added activity to beta test. Override the digital divide with additional clickthroughs from DevOps. Nanotechnology immersion along the information highway will close the loop on focusing solely on the bottom line.</p>\n",
      "date_published": "2018-09-30T00:00:00Z"
    },{
      "id": "https://jacobsherin.com/posts/thirdpost/",
      "url": "https://jacobsherin.com/posts/thirdpost/",
      "title": "This is my third post.",
      "content_html": "<p>Leverage agile frameworks to provide a robust synopsis for high level overviews. Iterative approaches to corporate strategy foster collaborative thinking to further the overall value proposition. Organically grow the holistic world view of disruptive innovation via workplace diversity and empowerment.</p>\n<pre class=\"language-diff-js\"><code class=\"language-diff-js\">// this is a command<br />function myCommand() {<br /><span class=\"token inserted-sign inserted language-js\"><span class=\"token prefix inserted\">+</span>\t<span class=\"token keyword\">let</span> counter <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><br /></span><br /><span class=\"token deleted-sign deleted language-js\"><span class=\"token prefix deleted\">-</span>\tcounter<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span><br /></span><br />}<br /><br />// Test with a line break above this line.<br />console.log('Test');</code></pre>\n<p>Bring to the table win-win survival strategies to ensure proactive domination. At the end of the day, going forward, a new normal that has evolved from generation X is on the runway heading towards a streamlined cloud solution. User generated content in real-time will have multiple touchpoints for offshoring.</p>\n<h2 id=\"section-header\" tabindex=\"-1\">Section Header <a class=\"direct-link\" href=\"https://jacobsherin.com/posts/thirdpost/#section-header\" aria-hidden=\"true\">#</a></h2>\n<p>Capitalize on low hanging fruit to identify a ballpark value added activity to beta test. Override the digital divide with additional clickthroughs from DevOps. Nanotechnology immersion along the information highway will close the loop on focusing solely on the bottom line.</p>\n",
      "date_published": "2018-08-24T00:00:00Z"
    },{
      "id": "https://jacobsherin.com/posts/secondpost/",
      "url": "https://jacobsherin.com/posts/secondpost/",
      "title": "This is my second post.",
      "content_html": "<p>Leverage agile frameworks to provide a robust synopsis for high level overviews. Iterative approaches to corporate strategy foster collaborative thinking to further the overall value proposition. Organically grow the holistic world view of disruptive innovation via workplace diversity and empowerment.</p>\n<h2 id=\"section-header\" tabindex=\"-1\">Section Header <a class=\"direct-link\" href=\"https://jacobsherin.com/posts/secondpost/#section-header\" aria-hidden=\"true\">#</a></h2>\n<p><a href=\"https://jacobsherin.com/posts/firstpost/\">First post</a><br />\n<a href=\"https://jacobsherin.com/posts/thirdpost/\">Third post</a></p>\n<p>Bring to the table win-win survival strategies to ensure proactive domination. At the end of the day, going forward, a new normal that has evolved from generation X is on the runway heading towards a streamlined cloud solution. User generated content in real-time will have multiple touchpoints for offshoring.</p>\n<p>Capitalize on low hanging fruit to identify a ballpark value added activity to beta test. Override the digital divide with additional clickthroughs from DevOps. Nanotechnology immersion along the information highway will close the loop on focusing solely on the bottom line.</p>\n",
      "date_published": "2018-07-04T00:00:00Z"
    },{
      "id": "https://jacobsherin.com/posts/firstpost/",
      "url": "https://jacobsherin.com/posts/firstpost/",
      "title": "This is my first post.",
      "content_html": "<p>Leverage agile frameworks to provide a robust synopsis for high level overviews. Iterative approaches to corporate strategy foster collaborative thinking to further the overall value proposition. Organically grow the holistic world view of disruptive innovation via workplace diversity and empowerment.</p>\n<p>Bring to the table win-win survival strategies to ensure proactive domination. At the end of the day, going forward, a new normal that has evolved from generation X is on the runway heading towards a streamlined cloud solution. User generated content in real-time will have multiple touchpoints for offshoring.</p>\n<h2 id=\"section-header\" tabindex=\"-1\">Section Header <a class=\"direct-link\" href=\"https://jacobsherin.com/posts/firstpost/#section-header\" aria-hidden=\"true\">#</a></h2>\n<p>Capitalize on low hanging fruit to identify a ballpark value added activity to beta test. Override the digital divide with additional clickthroughs from DevOps. Nanotechnology immersion along the information highway will close the loop on focusing solely on the bottom line.</p>\n<pre class=\"language-diff-js\"><code class=\"language-diff-js\">// this is a command<br />function myCommand() {<br /><span class=\"token inserted-sign inserted language-js\"><span class=\"token prefix inserted\">+</span>\t<span class=\"token keyword\">let</span> counter <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><br /><span class=\"token prefix inserted\">+</span>\tcounter<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span><br /></span>}<br /><br />// Test with a line break above this line.<br />console.log('Test');</code></pre>\n",
      "date_published": "2018-05-01T00:00:00Z"
    }
  ]
}
