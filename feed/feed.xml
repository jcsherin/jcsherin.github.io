<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<title>Jacob&#39;s blog</title>
	<subtitle>jcsherin writes about programming</subtitle>
	
	<link href="https://jacobsherin.com/feed/feed.xml" rel="self"/>
	<link href="https://jacobsherin.com/"/>
	<updated>2025-08-18T00:00:00Z</updated>
	<id>https://example.com/</id>
	<author>
		<name>Your Name Here</name>
		<email>youremailaddress@example.com</email>
	</author>
	
	<entry>
		<title>Cache-Friendly B+Tree Nodes With Dynamic Fanout</title>
		<link href="https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/"/>
		<updated>2025-08-18T00:00:00Z</updated>
		<id>https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/</id>
		<content type="html">&lt;p&gt;For a high-performance B+Tree, the memory layout of each node must be a single contiguous block. This improves locality of reference, increasing the likelihood that the node&#39;s contents reside in the CPU cache.&lt;/p&gt;
&lt;p&gt;In C++, achieving this means forgoing the use of &lt;code&gt;std::vector&lt;/code&gt;, as it introduces a layer of indirection through a separate memory allocation. The technique involved inevitably increases the implementation complexity and introduces several non-obvious drawbacks. Nevertheless, this is a necessary trade-off for unlocking high performance.&lt;/p&gt;
&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;  +----------------------+&lt;br /&gt;  | Node Metadata Header |&lt;br /&gt;  +----------------------+&lt;br /&gt;  | node_type            |  &lt;-- Identify as Inner or Leaf Node&lt;br /&gt;  | max_size             |  &lt;-- Maximum Capacity (aka Node Fanout)&lt;br /&gt;  | node_latch           |  &lt;-- RW-Lock Mutex&lt;br /&gt;  | iter_end_            |  &lt;-- Past-the-end Pointer&lt;br /&gt;  +----------------------+&lt;br /&gt;  | Node Data            |&lt;br /&gt;  +----------------------+  &lt;-- Key-Value Elements Stored From Here&lt;br /&gt;  | entries_[0]          |&lt;br /&gt;  | entries_[1]          |&lt;br /&gt;  | entries_[2]          |  &lt;-- iter_end_ (when current size = 2)&lt;br /&gt;  | ...                  |&lt;br /&gt;  | entries_[N]          |  &lt;-- N = max_size - 1&lt;br /&gt;  +----------------------+  &lt;-- iter_end_ (when node is full)&lt;/code&gt;&lt;/pre&gt;
&lt;figcaption&gt;Fig 1. Memory Layout of a B+Tree Node&lt;/figcaption&gt;
&lt;nav class=&quot;toc&quot; aria-labelledby=&quot;toc-heading&quot;&gt;
  &lt;h2 id=&quot;toc-heading&quot;&gt;Table of Contents&lt;/h2&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#challenges&quot;&gt;Challenges&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#the-struct-hack&quot;&gt;The Struct Hack&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#b+tree-node-declaration&quot;&gt;B+Tree Node Declaration&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#raw-memory-buffer&quot;&gt;Raw Memory Buffer&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;
      &lt;a href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#the-price-of-fine-grained-control&quot;&gt;The Price Of Fine-Grained Control&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#manual-handling-of-deallocation&quot;&gt;Manual Handling Of Deallocation&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#adding-new-members-in-a-derived-class&quot;&gt;Adding New Members In A Derived Class&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#reinventing-the-wheel&quot;&gt;Reinventing The Wheel&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#hidden-data-type-assumptions&quot;&gt;Hidden Data Type Assumptions&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/nav&gt;
&lt;h2 id=&quot;challenges&quot; tabindex=&quot;-1&quot;&gt;Challenges &lt;a class=&quot;direct-link&quot; href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#challenges&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Using &lt;code&gt;std::vector&lt;/code&gt; for a B+Tree node&#39;s entries is a non-starter. A &lt;code&gt;std::vector&lt;/code&gt; object holds a pointer to its entries which are stored in a separate block of memory on the heap. This indirection breaks up the memory layout, forcing us to fall back on C-style arrays for storing the node&#39;s entries.&lt;/p&gt;
&lt;p&gt;This leads to a dilemma. The size of the array must be known at compilation time, yet we need to allow users to configure the fanout (the array&#39;s size) at runtime. Furthermore, the implementation should allow inner nodes and leaf nodes to have different fanouts.&lt;/p&gt;
&lt;p&gt;This isn&#39;t just a B+Tree problem. It is a common challenge in systems programming whenever an object needs to contain a variable-length payload whose size is only known at runtime. How can you define a class that occupies a single block of memory when a part of the block has a dynamic size?&lt;/p&gt;
&lt;p&gt;The solution isn&#39;t obvious, but it&#39;s a well-known trick that systems programmers have used for decades--a technique so common it was eventually standardized in C99.&lt;/p&gt;
&lt;h2 id=&quot;the-struct-hack&quot; tabindex=&quot;-1&quot;&gt;The Struct Hack &lt;a class=&quot;direct-link&quot; href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#the-struct-hack&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The solution to this problem is a technique originating in C programming known as the struct hack. The variable-length member (implemented as an array) is placed at the last position in the struct. To satisfy the compiler a size of &lt;code&gt;1&lt;/code&gt; is specified, ensuring the array&#39;s size is known at compilation time.&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Payload&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;/* Header Section */&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;/* Data Section */&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// The variable-length member is in last position.&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// The size `1` satisfies the compiler.&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; elements&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At runtime, when the required size &lt;code&gt;N&lt;/code&gt; is known, you allocate a single block of memory for the struct and the &lt;code&gt;N&lt;/code&gt; elements combined. The compiler treats this as an opaque block, and provides no safety guarantees. However, accessing the extra allocated space is safe because the variable-length member is the final field in the struct.&lt;/p&gt;
&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// The (N - 1) adjusts for the 1-element array in Payload struct&lt;/span&gt;&lt;br /&gt;Payload &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;item &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Payload&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;N &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This pattern was officially standardized in C99, where it is known as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Flexible_array_member&quot;&gt;flexible array member&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The C++11 standard formally incorporates the flexible array member, referring to it as an &lt;strong&gt;array of unknown bound&lt;/strong&gt; when it is the last member of a struct.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Arrays of unknown bound&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;expr&lt;/code&gt; is omitted in the declaration of an array, the type declared is &amp;quot;array of unknown bound of T&amp;quot;, which is a kind of incomplete type, ...&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;token comment&quot;&gt;// the type of x is &quot;array of unknown bound of int&quot;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// the type of a is &quot;array of 3 int&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;This means that in C++, the size can be omitted from the final array declaration (e.g. &lt;code&gt;entries_[]&lt;/code&gt;), and the code will compile, enabling the same pattern.&lt;/p&gt;
&lt;h2 id=&quot;b+tree-node-declaration&quot; tabindex=&quot;-1&quot;&gt;B+Tree Node Declaration &lt;a class=&quot;direct-link&quot; href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#b+tree-node-declaration&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Using the flexible array member syntax, we can now declare a B+Tree node with a memory layout which is a continuous single block in the heap.&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;KeyType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ValueType&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BPlusTreeNode&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;using&lt;/span&gt; KeyValuePair &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; std&lt;span class=&quot;token double-colon punctuation&quot;&gt;::&lt;/span&gt;pair&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;KeyType&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ValueType&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// Node Header Members ... (elided)&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// Points to the memory location beyond the last key-value&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// entry in the `entries_` array.&lt;/span&gt;&lt;br /&gt;  KeyValuePair&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; iter_end_&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// Array containing key-value entries of unknown bound.&lt;/span&gt;&lt;br /&gt;  KeyValuePair entries_&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using a &lt;code&gt;std::vector&amp;lt;KeyValuePair&amp;gt;&lt;/code&gt; for the node&#39;s entries would result in an indirection. This immediately fragments the memory layout. Attempting to access a node entry will be noticeably slower. The pointer indirection is costly: following the pointer increases the risk of a cache miss, forcing the CPU to stall and wait for the cache line to be fetched from main memory.&lt;/p&gt;
&lt;p&gt;A cache miss may cost hundreds of CPU cycles compared to just a few cycles for a cache hit. This cumulative latency is unacceptable for any high-performance data structure.&lt;/p&gt;
&lt;p&gt;This technique avoids the pointer indirection and provides fine-grained control over memory layout. The node header and data are co-located in one continuous memory block. This layout is cache-friendly and will result in fewer cache misses.&lt;/p&gt;
&lt;h2 id=&quot;raw-memory-buffer&quot; tabindex=&quot;-1&quot;&gt;Raw Memory Buffer &lt;a class=&quot;direct-link&quot; href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#raw-memory-buffer&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This is the key step. The construction of the object has to be separate from its memory allocation. We cannot therefor use the standard &lt;code&gt;new&lt;/code&gt; syntax which will attempt to allocate storage, and then initialize the object in the same storage.&lt;/p&gt;
&lt;p&gt;Instead we will use the &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/new.html#Placement_new&quot;&gt;placement new&lt;/a&gt; syntax which will construct objects in the memory buffer we created. We know exactly how much space to allocate, which is information the standard &lt;code&gt;new&lt;/code&gt; operator does not have in this scenario because of the flexible array member.&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// A static helper to allocate storage for a B+Tree node.&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; BPlusTreeNode &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; p_fanout&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// calculate total buffer size&lt;/span&gt;&lt;br /&gt;  size_t buf_size &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;BPlusTreeNode&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; p_fanout &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;KeyValuePair&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// allocate raw memory buffer&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;buf &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token double-colon punctuation&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;buf_size&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// construct B+Tree node object in the preallocated buffer&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;auto&lt;/span&gt; node &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;buf&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;BPlusTreeNode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p_fanout&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; node&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have now successfully created a cache-friendly B+Tree node with a user-defined fanout configuration which is known only at runtime.&lt;/p&gt;
&lt;h2 id=&quot;the-price-of-fine-grained-control&quot; tabindex=&quot;-1&quot;&gt;The Price Of Fine-Grained Control &lt;a class=&quot;direct-link&quot; href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#the-price-of-fine-grained-control&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To create an instance of a B+Tree node with a fanout of &lt;code&gt;256&lt;/code&gt;, it is not possible to write simple idiomatic code like this: &lt;code&gt;new BPlusTreeNode(256)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Instead we use the custom &lt;code&gt;BPlusTreeNode::Get&lt;/code&gt; helper which knows how much raw memory to allocate for the object including the data section.&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;BPlusTreeNode &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;root &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BPlusTreeNode&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;KeyValuePair&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token double-colon punctuation&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;manual-handling-of-deallocation&quot; tabindex=&quot;-1&quot;&gt;Manual Handling Of Deallocation &lt;a class=&quot;direct-link&quot; href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#manual-handling-of-deallocation&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The destructor code is also not idiomatic anymore. When the lifetime of the B+Tree node ends, the deallocation code has to be carefully crafted to avoid resource or memory leaks.&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BPlusTreeNode&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;FreeNode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// Call the destructor for each key-value entry.&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;KeyValuePair&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; element &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; entries_&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; element &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; iter_end_&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;element&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      element&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;KeyValuePair&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// Call the node destructor&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;BPlusTreeNode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// Deallocate the raw memory&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token double-colon punctuation&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;adding-new-members-in-a-derived-class&quot; tabindex=&quot;-1&quot;&gt;Adding New Members In A Derived Class &lt;a class=&quot;direct-link&quot; href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#adding-new-members-in-a-derived-class&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Adding a new member to a derived class will result in data corruption. It is not possible to add new fields to a specialized &lt;code&gt;InnerNode&lt;/code&gt; or &lt;code&gt;LeafNode&lt;/code&gt; class.&lt;/p&gt;
&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;+-----------------------+&lt;br /&gt;| BPlusTreeNode Members |&lt;br /&gt;| (Header)              |&lt;br /&gt;+-----------------------+ &lt;-- offset where the data buffer starts&lt;br /&gt;| entries_[0]             | &lt;-- where the compiler thinks derived class&lt;br /&gt;| entries_[1]             |     member are written to&lt;br /&gt;| ...                   |&lt;br /&gt;| entries_[N]             |&lt;br /&gt;+-----------------------+ &lt;-- iter_end_&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The raw memory we manually allocated is opaque to the compiler and it cannot safely reason about where the newly added members to the derived class are physically located. The end result is it will overwrite the data buffer and cause data corruption.&lt;/p&gt;
&lt;p&gt;The workaround is to break encapsulation and add derived members to the base class so that the flexible array member is always in the last position. This is a significant drawback when we begin using flexible array members.&lt;/p&gt;
&lt;h3 id=&quot;reinventing-the-wheel&quot; tabindex=&quot;-1&quot;&gt;Reinventing The Wheel &lt;a class=&quot;direct-link&quot; href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#reinventing-the-wheel&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For the data array we now effectively end up reinventing &lt;code&gt;std::vector&lt;/code&gt; utilities for insertion, deletion and iteration. This includes bound-checking to prevent buffer overflows.&lt;/p&gt;
&lt;p&gt;This significantly raises the complexity, and maintenance burden of the implementation. We also have to make sure that our custom implementation is performant at par, with the standard library implementation.&lt;/p&gt;
&lt;h3 id=&quot;hidden-data-type-assumptions&quot; tabindex=&quot;-1&quot;&gt;Hidden Data Type Assumptions &lt;a class=&quot;direct-link&quot; href=&quot;https://jacobsherin.com/posts/2025-08-18-bplustree-struct-hack/#hidden-data-type-assumptions&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The following is an implementation for inserting a &lt;code&gt;KeyValuePair&lt;/code&gt; element in the data array.&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Insert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; KeyValuePair &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;element&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; KeyValuePair &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;pos&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// The node is currently full so we cannot insert this element.&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;GetCurrentSize&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;GetMaxSize&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// Shift elements from `pos` to the right by one to make&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// place for inserting new `element`.&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;std&lt;span class=&quot;token double-colon punctuation&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pos&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;End&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      std&lt;span class=&quot;token double-colon punctuation&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;memmove&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token generic-function&quot;&gt;&lt;span class=&quot;token function&quot;&gt;reinterpret_cast&lt;/span&gt;&lt;span class=&quot;token generic class-name&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;std&lt;span class=&quot;token double-colon punctuation&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pos&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Destination&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token generic-function&quot;&gt;&lt;span class=&quot;token function&quot;&gt;reinterpret_cast&lt;/span&gt;&lt;span class=&quot;token generic class-name&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pos&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Source&lt;/span&gt;&lt;br /&gt;        std&lt;span class=&quot;token double-colon punctuation&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pos&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;End&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;KeyValuePair&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Count&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// Insert element at `pos`.&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pos&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; KeyValuePair&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;element&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// Bookkeeping&lt;/span&gt;&lt;br /&gt;  std&lt;span class=&quot;token double-colon punctuation&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;advance&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;iter_end_&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code above uses &lt;code&gt;std::memmove&lt;/code&gt; to shift entries within the node. This introduces a hidden constraint, that the data types implementing the &lt;code&gt;BPlusTreeNode&lt;/code&gt; should be POD (plain old data) types or trivially copyable.&lt;/p&gt;
&lt;p&gt;The class interface is generic over the key and value types. But it doesn&#39;t convey this constraint to the user of the &lt;code&gt;BPlusTreeNode&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;KeyType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ValueType&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BPlusTreeNode&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;using&lt;/span&gt; KeyValuePair &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; std&lt;span class=&quot;token double-colon punctuation&quot;&gt;::&lt;/span&gt;pair&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;KeyType&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ValueType&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we used &lt;code&gt;std::string&lt;/code&gt; as either the &lt;code&gt;KeyType&lt;/code&gt; or &lt;code&gt;ValueType&lt;/code&gt; then calling the &lt;code&gt;Insert&lt;/code&gt; method introduces undefined behavior. Copying a &lt;code&gt;std::string&lt;/code&gt; object with &lt;code&gt;memmove&lt;/code&gt; creates a shallow copy of its internal pointers. When the original string is destroyed, it will deallocate the memory, leaving the copied string with a dangling pointer.&lt;/p&gt;
</content>
	</entry>
</feed>
