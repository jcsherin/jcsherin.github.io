<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jacob&#39;s blog</title>
    <meta name="description" content="On database building blocks.">
    <meta name="generator" content="Eleventy v1.0.1">
    <link rel="stylesheet" href="/css/prism-okaidia.css">
    <link rel="stylesheet" href="/css/custom.css?v=1758719081582">
    <link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="">
    <link rel="alternate" href="/feed/feed.json" type="application/json" title="">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inria+Serif:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
    <script>document.documentElement.classList.remove("no-js");</script>
  </head>
  <body>
    <div class="page-wrapper">
      <header>
        <hgroup>
        <p><a href="/">Jacob&#39;s blog</a></p>
        <p>On database building blocks.</p>
      </hgroup>
        <ul class="nav">
          <li class="nav-item nav-item-active">posts</li>
          <li class="nav-item"><a href="/about/">whoami</a></li>
        </ul>
      </header>

      <main class="tmpl-home">
        

<div class="post-list">
  
    <article class="post-list-item">
      <div class="post-list-meta">
        <time datetime="2025-08-18">18 Aug 2025</time>
        <h2 class="post-list-title">
          <a href="/posts/2025-08-18-bplustree-struct-hack/">Cache-Friendly B+Tree Nodes With Dynamic Fanout</a>
        </h2>
      </div>
      
        <p class="post-list-summary">
          A B+Tree node requires a contiguous, cache-friendly memory layout and a dynamic number of entries, but standard C++ tools falls short on both ends. This post explores how to solve this classic problem using the &quot;struct hack&quot; and manual memory management, while also exposing the higher complexity and drawbacks involved when chasing raw performance.

        </p>
      
    </article>
  
    <article class="post-list-item">
      <div class="post-list-meta">
        <time datetime="2025-08-16">16 Aug 2025</time>
        <h2 class="post-list-title">
          <a href="/posts/2025-08-16-bplustree-compare-borrow-merge/">A B+Tree Node Underflows: Merge or Borrow?</a>
        </h2>
      </div>
      
        <p class="post-list-summary">
          The stable logarithmic performance of a B+Tree is an outcome of its self-balancing property. When an inner node or leaf node falls below its minimum occupancy threshold during deletions, the tree rebalancing procedure is activated. The first choice is to either merge with a sibling, or borrow (redistribute) keys from a sibling. Neither choice is inherently better. Instead, the design decision signals the fundamental trade-off preferred by the specific implementation. A survey of major OLTP systems reveals a design space that is far more nuanced than this simple binary choice suggests.

        </p>
      
    </article>
  
</div>





      </main>

      <footer></footer>

      <!-- Current page: / -->
    </body>
  </div>
</html>
